package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/Sysleec/auth/internal/client/db.NamedExecer -o named_execer_minimock.go -n NamedExecerMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_db "github.com/Sysleec/auth/internal/client/db"
	"github.com/gojuno/minimock/v3"
)

// NamedExecerMock implements db.NamedExecer
type NamedExecerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcScanAllContext          func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error)
	inspectFuncScanAllContext   func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{})
	afterScanAllContextCounter  uint64
	beforeScanAllContextCounter uint64
	ScanAllContextMock          mNamedExecerMockScanAllContext

	funcScanOneContext          func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error)
	inspectFuncScanOneContext   func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{})
	afterScanOneContextCounter  uint64
	beforeScanOneContextCounter uint64
	ScanOneContextMock          mNamedExecerMockScanOneContext
}

// NewNamedExecerMock returns a mock for db.NamedExecer
func NewNamedExecerMock(t minimock.Tester) *NamedExecerMock {
	m := &NamedExecerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ScanAllContextMock = mNamedExecerMockScanAllContext{mock: m}
	m.ScanAllContextMock.callArgs = []*NamedExecerMockScanAllContextParams{}

	m.ScanOneContextMock = mNamedExecerMockScanOneContext{mock: m}
	m.ScanOneContextMock.callArgs = []*NamedExecerMockScanOneContextParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mNamedExecerMockScanAllContext struct {
	mock               *NamedExecerMock
	defaultExpectation *NamedExecerMockScanAllContextExpectation
	expectations       []*NamedExecerMockScanAllContextExpectation

	callArgs []*NamedExecerMockScanAllContextParams
	mutex    sync.RWMutex
}

// NamedExecerMockScanAllContextExpectation specifies expectation struct of the NamedExecer.ScanAllContext
type NamedExecerMockScanAllContextExpectation struct {
	mock    *NamedExecerMock
	params  *NamedExecerMockScanAllContextParams
	results *NamedExecerMockScanAllContextResults
	Counter uint64
}

// NamedExecerMockScanAllContextParams contains parameters of the NamedExecer.ScanAllContext
type NamedExecerMockScanAllContextParams struct {
	ctx  context.Context
	dest interface{}
	q    mm_db.Query
	args []interface{}
}

// NamedExecerMockScanAllContextResults contains results of the NamedExecer.ScanAllContext
type NamedExecerMockScanAllContextResults struct {
	err error
}

// Expect sets up expected params for NamedExecer.ScanAllContext
func (mmScanAllContext *mNamedExecerMockScanAllContext) Expect(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) *mNamedExecerMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("NamedExecerMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &NamedExecerMockScanAllContextExpectation{}
	}

	mmScanAllContext.defaultExpectation.params = &NamedExecerMockScanAllContextParams{ctx, dest, q, args}
	for _, e := range mmScanAllContext.expectations {
		if minimock.Equal(e.params, mmScanAllContext.defaultExpectation.params) {
			mmScanAllContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanAllContext.defaultExpectation.params)
		}
	}

	return mmScanAllContext
}

// Inspect accepts an inspector function that has same arguments as the NamedExecer.ScanAllContext
func (mmScanAllContext *mNamedExecerMockScanAllContext) Inspect(f func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{})) *mNamedExecerMockScanAllContext {
	if mmScanAllContext.mock.inspectFuncScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("Inspect function is already set for NamedExecerMock.ScanAllContext")
	}

	mmScanAllContext.mock.inspectFuncScanAllContext = f

	return mmScanAllContext
}

// Return sets up results that will be returned by NamedExecer.ScanAllContext
func (mmScanAllContext *mNamedExecerMockScanAllContext) Return(err error) *NamedExecerMock {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("NamedExecerMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &NamedExecerMockScanAllContextExpectation{mock: mmScanAllContext.mock}
	}
	mmScanAllContext.defaultExpectation.results = &NamedExecerMockScanAllContextResults{err}
	return mmScanAllContext.mock
}

// Set uses given function f to mock the NamedExecer.ScanAllContext method
func (mmScanAllContext *mNamedExecerMockScanAllContext) Set(f func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error)) *NamedExecerMock {
	if mmScanAllContext.defaultExpectation != nil {
		mmScanAllContext.mock.t.Fatalf("Default expectation is already set for the NamedExecer.ScanAllContext method")
	}

	if len(mmScanAllContext.expectations) > 0 {
		mmScanAllContext.mock.t.Fatalf("Some expectations are already set for the NamedExecer.ScanAllContext method")
	}

	mmScanAllContext.mock.funcScanAllContext = f
	return mmScanAllContext.mock
}

// When sets expectation for the NamedExecer.ScanAllContext which will trigger the result defined by the following
// Then helper
func (mmScanAllContext *mNamedExecerMockScanAllContext) When(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) *NamedExecerMockScanAllContextExpectation {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("NamedExecerMock.ScanAllContext mock is already set by Set")
	}

	expectation := &NamedExecerMockScanAllContextExpectation{
		mock:   mmScanAllContext.mock,
		params: &NamedExecerMockScanAllContextParams{ctx, dest, q, args},
	}
	mmScanAllContext.expectations = append(mmScanAllContext.expectations, expectation)
	return expectation
}

// Then sets up NamedExecer.ScanAllContext return parameters for the expectation previously defined by the When method
func (e *NamedExecerMockScanAllContextExpectation) Then(err error) *NamedExecerMock {
	e.results = &NamedExecerMockScanAllContextResults{err}
	return e.mock
}

// ScanAllContext implements db.NamedExecer
func (mmScanAllContext *NamedExecerMock) ScanAllContext(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScanAllContext.beforeScanAllContextCounter, 1)
	defer mm_atomic.AddUint64(&mmScanAllContext.afterScanAllContextCounter, 1)

	if mmScanAllContext.inspectFuncScanAllContext != nil {
		mmScanAllContext.inspectFuncScanAllContext(ctx, dest, q, args...)
	}

	mm_params := NamedExecerMockScanAllContextParams{ctx, dest, q, args}

	// Record call args
	mmScanAllContext.ScanAllContextMock.mutex.Lock()
	mmScanAllContext.ScanAllContextMock.callArgs = append(mmScanAllContext.ScanAllContextMock.callArgs, &mm_params)
	mmScanAllContext.ScanAllContextMock.mutex.Unlock()

	for _, e := range mmScanAllContext.ScanAllContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScanAllContext.ScanAllContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanAllContext.ScanAllContextMock.defaultExpectation.Counter, 1)
		mm_want := mmScanAllContext.ScanAllContextMock.defaultExpectation.params
		mm_got := NamedExecerMockScanAllContextParams{ctx, dest, q, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanAllContext.t.Errorf("NamedExecerMock.ScanAllContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanAllContext.ScanAllContextMock.defaultExpectation.results
		if mm_results == nil {
			mmScanAllContext.t.Fatal("No results are set for the NamedExecerMock.ScanAllContext")
		}
		return (*mm_results).err
	}
	if mmScanAllContext.funcScanAllContext != nil {
		return mmScanAllContext.funcScanAllContext(ctx, dest, q, args...)
	}
	mmScanAllContext.t.Fatalf("Unexpected call to NamedExecerMock.ScanAllContext. %v %v %v %v", ctx, dest, q, args)
	return
}

// ScanAllContextAfterCounter returns a count of finished NamedExecerMock.ScanAllContext invocations
func (mmScanAllContext *NamedExecerMock) ScanAllContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanAllContext.afterScanAllContextCounter)
}

// ScanAllContextBeforeCounter returns a count of NamedExecerMock.ScanAllContext invocations
func (mmScanAllContext *NamedExecerMock) ScanAllContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanAllContext.beforeScanAllContextCounter)
}

// Calls returns a list of arguments used in each call to NamedExecerMock.ScanAllContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanAllContext *mNamedExecerMockScanAllContext) Calls() []*NamedExecerMockScanAllContextParams {
	mmScanAllContext.mutex.RLock()

	argCopy := make([]*NamedExecerMockScanAllContextParams, len(mmScanAllContext.callArgs))
	copy(argCopy, mmScanAllContext.callArgs)

	mmScanAllContext.mutex.RUnlock()

	return argCopy
}

// MinimockScanAllContextDone returns true if the count of the ScanAllContext invocations corresponds
// the number of defined expectations
func (m *NamedExecerMock) MinimockScanAllContextDone() bool {
	for _, e := range m.ScanAllContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanAllContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanAllContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanAllContext != nil && mm_atomic.LoadUint64(&m.afterScanAllContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockScanAllContextInspect logs each unmet expectation
func (m *NamedExecerMock) MinimockScanAllContextInspect() {
	for _, e := range m.ScanAllContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NamedExecerMock.ScanAllContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanAllContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanAllContextCounter) < 1 {
		if m.ScanAllContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NamedExecerMock.ScanAllContext")
		} else {
			m.t.Errorf("Expected call to NamedExecerMock.ScanAllContext with params: %#v", *m.ScanAllContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanAllContext != nil && mm_atomic.LoadUint64(&m.afterScanAllContextCounter) < 1 {
		m.t.Error("Expected call to NamedExecerMock.ScanAllContext")
	}
}

type mNamedExecerMockScanOneContext struct {
	mock               *NamedExecerMock
	defaultExpectation *NamedExecerMockScanOneContextExpectation
	expectations       []*NamedExecerMockScanOneContextExpectation

	callArgs []*NamedExecerMockScanOneContextParams
	mutex    sync.RWMutex
}

// NamedExecerMockScanOneContextExpectation specifies expectation struct of the NamedExecer.ScanOneContext
type NamedExecerMockScanOneContextExpectation struct {
	mock    *NamedExecerMock
	params  *NamedExecerMockScanOneContextParams
	results *NamedExecerMockScanOneContextResults
	Counter uint64
}

// NamedExecerMockScanOneContextParams contains parameters of the NamedExecer.ScanOneContext
type NamedExecerMockScanOneContextParams struct {
	ctx  context.Context
	dest interface{}
	q    mm_db.Query
	args []interface{}
}

// NamedExecerMockScanOneContextResults contains results of the NamedExecer.ScanOneContext
type NamedExecerMockScanOneContextResults struct {
	err error
}

// Expect sets up expected params for NamedExecer.ScanOneContext
func (mmScanOneContext *mNamedExecerMockScanOneContext) Expect(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) *mNamedExecerMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("NamedExecerMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &NamedExecerMockScanOneContextExpectation{}
	}

	mmScanOneContext.defaultExpectation.params = &NamedExecerMockScanOneContextParams{ctx, dest, q, args}
	for _, e := range mmScanOneContext.expectations {
		if minimock.Equal(e.params, mmScanOneContext.defaultExpectation.params) {
			mmScanOneContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanOneContext.defaultExpectation.params)
		}
	}

	return mmScanOneContext
}

// Inspect accepts an inspector function that has same arguments as the NamedExecer.ScanOneContext
func (mmScanOneContext *mNamedExecerMockScanOneContext) Inspect(f func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{})) *mNamedExecerMockScanOneContext {
	if mmScanOneContext.mock.inspectFuncScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("Inspect function is already set for NamedExecerMock.ScanOneContext")
	}

	mmScanOneContext.mock.inspectFuncScanOneContext = f

	return mmScanOneContext
}

// Return sets up results that will be returned by NamedExecer.ScanOneContext
func (mmScanOneContext *mNamedExecerMockScanOneContext) Return(err error) *NamedExecerMock {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("NamedExecerMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &NamedExecerMockScanOneContextExpectation{mock: mmScanOneContext.mock}
	}
	mmScanOneContext.defaultExpectation.results = &NamedExecerMockScanOneContextResults{err}
	return mmScanOneContext.mock
}

// Set uses given function f to mock the NamedExecer.ScanOneContext method
func (mmScanOneContext *mNamedExecerMockScanOneContext) Set(f func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error)) *NamedExecerMock {
	if mmScanOneContext.defaultExpectation != nil {
		mmScanOneContext.mock.t.Fatalf("Default expectation is already set for the NamedExecer.ScanOneContext method")
	}

	if len(mmScanOneContext.expectations) > 0 {
		mmScanOneContext.mock.t.Fatalf("Some expectations are already set for the NamedExecer.ScanOneContext method")
	}

	mmScanOneContext.mock.funcScanOneContext = f
	return mmScanOneContext.mock
}

// When sets expectation for the NamedExecer.ScanOneContext which will trigger the result defined by the following
// Then helper
func (mmScanOneContext *mNamedExecerMockScanOneContext) When(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) *NamedExecerMockScanOneContextExpectation {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("NamedExecerMock.ScanOneContext mock is already set by Set")
	}

	expectation := &NamedExecerMockScanOneContextExpectation{
		mock:   mmScanOneContext.mock,
		params: &NamedExecerMockScanOneContextParams{ctx, dest, q, args},
	}
	mmScanOneContext.expectations = append(mmScanOneContext.expectations, expectation)
	return expectation
}

// Then sets up NamedExecer.ScanOneContext return parameters for the expectation previously defined by the When method
func (e *NamedExecerMockScanOneContextExpectation) Then(err error) *NamedExecerMock {
	e.results = &NamedExecerMockScanOneContextResults{err}
	return e.mock
}

// ScanOneContext implements db.NamedExecer
func (mmScanOneContext *NamedExecerMock) ScanOneContext(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScanOneContext.beforeScanOneContextCounter, 1)
	defer mm_atomic.AddUint64(&mmScanOneContext.afterScanOneContextCounter, 1)

	if mmScanOneContext.inspectFuncScanOneContext != nil {
		mmScanOneContext.inspectFuncScanOneContext(ctx, dest, q, args...)
	}

	mm_params := NamedExecerMockScanOneContextParams{ctx, dest, q, args}

	// Record call args
	mmScanOneContext.ScanOneContextMock.mutex.Lock()
	mmScanOneContext.ScanOneContextMock.callArgs = append(mmScanOneContext.ScanOneContextMock.callArgs, &mm_params)
	mmScanOneContext.ScanOneContextMock.mutex.Unlock()

	for _, e := range mmScanOneContext.ScanOneContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScanOneContext.ScanOneContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanOneContext.ScanOneContextMock.defaultExpectation.Counter, 1)
		mm_want := mmScanOneContext.ScanOneContextMock.defaultExpectation.params
		mm_got := NamedExecerMockScanOneContextParams{ctx, dest, q, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanOneContext.t.Errorf("NamedExecerMock.ScanOneContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanOneContext.ScanOneContextMock.defaultExpectation.results
		if mm_results == nil {
			mmScanOneContext.t.Fatal("No results are set for the NamedExecerMock.ScanOneContext")
		}
		return (*mm_results).err
	}
	if mmScanOneContext.funcScanOneContext != nil {
		return mmScanOneContext.funcScanOneContext(ctx, dest, q, args...)
	}
	mmScanOneContext.t.Fatalf("Unexpected call to NamedExecerMock.ScanOneContext. %v %v %v %v", ctx, dest, q, args)
	return
}

// ScanOneContextAfterCounter returns a count of finished NamedExecerMock.ScanOneContext invocations
func (mmScanOneContext *NamedExecerMock) ScanOneContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanOneContext.afterScanOneContextCounter)
}

// ScanOneContextBeforeCounter returns a count of NamedExecerMock.ScanOneContext invocations
func (mmScanOneContext *NamedExecerMock) ScanOneContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanOneContext.beforeScanOneContextCounter)
}

// Calls returns a list of arguments used in each call to NamedExecerMock.ScanOneContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanOneContext *mNamedExecerMockScanOneContext) Calls() []*NamedExecerMockScanOneContextParams {
	mmScanOneContext.mutex.RLock()

	argCopy := make([]*NamedExecerMockScanOneContextParams, len(mmScanOneContext.callArgs))
	copy(argCopy, mmScanOneContext.callArgs)

	mmScanOneContext.mutex.RUnlock()

	return argCopy
}

// MinimockScanOneContextDone returns true if the count of the ScanOneContext invocations corresponds
// the number of defined expectations
func (m *NamedExecerMock) MinimockScanOneContextDone() bool {
	for _, e := range m.ScanOneContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanOneContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanOneContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanOneContext != nil && mm_atomic.LoadUint64(&m.afterScanOneContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockScanOneContextInspect logs each unmet expectation
func (m *NamedExecerMock) MinimockScanOneContextInspect() {
	for _, e := range m.ScanOneContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to NamedExecerMock.ScanOneContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanOneContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanOneContextCounter) < 1 {
		if m.ScanOneContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to NamedExecerMock.ScanOneContext")
		} else {
			m.t.Errorf("Expected call to NamedExecerMock.ScanOneContext with params: %#v", *m.ScanOneContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanOneContext != nil && mm_atomic.LoadUint64(&m.afterScanOneContextCounter) < 1 {
		m.t.Error("Expected call to NamedExecerMock.ScanOneContext")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *NamedExecerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockScanAllContextInspect()

			m.MinimockScanOneContextInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *NamedExecerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *NamedExecerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockScanAllContextDone() &&
		m.MinimockScanOneContextDone()
}
