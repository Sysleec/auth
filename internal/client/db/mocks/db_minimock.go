package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/Sysleec/auth/internal/client/db.DB -o db_minimock.go -n DBMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_db "github.com/Sysleec/auth/internal/client/db"
	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
)

// DBMock implements db.DB
type DBMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBeginTx          func(ctx context.Context, txOptions pgx.TxOptions) (t1 pgx.Tx, err error)
	inspectFuncBeginTx   func(ctx context.Context, txOptions pgx.TxOptions)
	afterBeginTxCounter  uint64
	beforeBeginTxCounter uint64
	BeginTxMock          mDBMockBeginTx

	funcClose          func()
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mDBMockClose

	funcExecContext          func(ctx context.Context, q mm_db.Query, args ...interface{}) (c2 pgconn.CommandTag, err error)
	inspectFuncExecContext   func(ctx context.Context, q mm_db.Query, args ...interface{})
	afterExecContextCounter  uint64
	beforeExecContextCounter uint64
	ExecContextMock          mDBMockExecContext

	funcPing          func(ctx context.Context) (err error)
	inspectFuncPing   func(ctx context.Context)
	afterPingCounter  uint64
	beforePingCounter uint64
	PingMock          mDBMockPing

	funcQueryContext          func(ctx context.Context, q mm_db.Query, args ...interface{}) (r1 pgx.Rows, err error)
	inspectFuncQueryContext   func(ctx context.Context, q mm_db.Query, args ...interface{})
	afterQueryContextCounter  uint64
	beforeQueryContextCounter uint64
	QueryContextMock          mDBMockQueryContext

	funcQueryRowContext          func(ctx context.Context, q mm_db.Query, args ...interface{}) (r1 pgx.Row)
	inspectFuncQueryRowContext   func(ctx context.Context, q mm_db.Query, args ...interface{})
	afterQueryRowContextCounter  uint64
	beforeQueryRowContextCounter uint64
	QueryRowContextMock          mDBMockQueryRowContext

	funcScanAllContext          func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error)
	inspectFuncScanAllContext   func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{})
	afterScanAllContextCounter  uint64
	beforeScanAllContextCounter uint64
	ScanAllContextMock          mDBMockScanAllContext

	funcScanOneContext          func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error)
	inspectFuncScanOneContext   func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{})
	afterScanOneContextCounter  uint64
	beforeScanOneContextCounter uint64
	ScanOneContextMock          mDBMockScanOneContext
}

// NewDBMock returns a mock for db.DB
func NewDBMock(t minimock.Tester) *DBMock {
	m := &DBMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginTxMock = mDBMockBeginTx{mock: m}
	m.BeginTxMock.callArgs = []*DBMockBeginTxParams{}

	m.CloseMock = mDBMockClose{mock: m}

	m.ExecContextMock = mDBMockExecContext{mock: m}
	m.ExecContextMock.callArgs = []*DBMockExecContextParams{}

	m.PingMock = mDBMockPing{mock: m}
	m.PingMock.callArgs = []*DBMockPingParams{}

	m.QueryContextMock = mDBMockQueryContext{mock: m}
	m.QueryContextMock.callArgs = []*DBMockQueryContextParams{}

	m.QueryRowContextMock = mDBMockQueryRowContext{mock: m}
	m.QueryRowContextMock.callArgs = []*DBMockQueryRowContextParams{}

	m.ScanAllContextMock = mDBMockScanAllContext{mock: m}
	m.ScanAllContextMock.callArgs = []*DBMockScanAllContextParams{}

	m.ScanOneContextMock = mDBMockScanOneContext{mock: m}
	m.ScanOneContextMock.callArgs = []*DBMockScanOneContextParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mDBMockBeginTx struct {
	mock               *DBMock
	defaultExpectation *DBMockBeginTxExpectation
	expectations       []*DBMockBeginTxExpectation

	callArgs []*DBMockBeginTxParams
	mutex    sync.RWMutex
}

// DBMockBeginTxExpectation specifies expectation struct of the DB.BeginTx
type DBMockBeginTxExpectation struct {
	mock    *DBMock
	params  *DBMockBeginTxParams
	results *DBMockBeginTxResults
	Counter uint64
}

// DBMockBeginTxParams contains parameters of the DB.BeginTx
type DBMockBeginTxParams struct {
	ctx       context.Context
	txOptions pgx.TxOptions
}

// DBMockBeginTxResults contains results of the DB.BeginTx
type DBMockBeginTxResults struct {
	t1  pgx.Tx
	err error
}

// Expect sets up expected params for DB.BeginTx
func (mmBeginTx *mDBMockBeginTx) Expect(ctx context.Context, txOptions pgx.TxOptions) *mDBMockBeginTx {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Set")
	}

	if mmBeginTx.defaultExpectation == nil {
		mmBeginTx.defaultExpectation = &DBMockBeginTxExpectation{}
	}

	mmBeginTx.defaultExpectation.params = &DBMockBeginTxParams{ctx, txOptions}
	for _, e := range mmBeginTx.expectations {
		if minimock.Equal(e.params, mmBeginTx.defaultExpectation.params) {
			mmBeginTx.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBeginTx.defaultExpectation.params)
		}
	}

	return mmBeginTx
}

// Inspect accepts an inspector function that has same arguments as the DB.BeginTx
func (mmBeginTx *mDBMockBeginTx) Inspect(f func(ctx context.Context, txOptions pgx.TxOptions)) *mDBMockBeginTx {
	if mmBeginTx.mock.inspectFuncBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("Inspect function is already set for DBMock.BeginTx")
	}

	mmBeginTx.mock.inspectFuncBeginTx = f

	return mmBeginTx
}

// Return sets up results that will be returned by DB.BeginTx
func (mmBeginTx *mDBMockBeginTx) Return(t1 pgx.Tx, err error) *DBMock {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Set")
	}

	if mmBeginTx.defaultExpectation == nil {
		mmBeginTx.defaultExpectation = &DBMockBeginTxExpectation{mock: mmBeginTx.mock}
	}
	mmBeginTx.defaultExpectation.results = &DBMockBeginTxResults{t1, err}
	return mmBeginTx.mock
}

// Set uses given function f to mock the DB.BeginTx method
func (mmBeginTx *mDBMockBeginTx) Set(f func(ctx context.Context, txOptions pgx.TxOptions) (t1 pgx.Tx, err error)) *DBMock {
	if mmBeginTx.defaultExpectation != nil {
		mmBeginTx.mock.t.Fatalf("Default expectation is already set for the DB.BeginTx method")
	}

	if len(mmBeginTx.expectations) > 0 {
		mmBeginTx.mock.t.Fatalf("Some expectations are already set for the DB.BeginTx method")
	}

	mmBeginTx.mock.funcBeginTx = f
	return mmBeginTx.mock
}

// When sets expectation for the DB.BeginTx which will trigger the result defined by the following
// Then helper
func (mmBeginTx *mDBMockBeginTx) When(ctx context.Context, txOptions pgx.TxOptions) *DBMockBeginTxExpectation {
	if mmBeginTx.mock.funcBeginTx != nil {
		mmBeginTx.mock.t.Fatalf("DBMock.BeginTx mock is already set by Set")
	}

	expectation := &DBMockBeginTxExpectation{
		mock:   mmBeginTx.mock,
		params: &DBMockBeginTxParams{ctx, txOptions},
	}
	mmBeginTx.expectations = append(mmBeginTx.expectations, expectation)
	return expectation
}

// Then sets up DB.BeginTx return parameters for the expectation previously defined by the When method
func (e *DBMockBeginTxExpectation) Then(t1 pgx.Tx, err error) *DBMock {
	e.results = &DBMockBeginTxResults{t1, err}
	return e.mock
}

// BeginTx implements db.DB
func (mmBeginTx *DBMock) BeginTx(ctx context.Context, txOptions pgx.TxOptions) (t1 pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmBeginTx.beforeBeginTxCounter, 1)
	defer mm_atomic.AddUint64(&mmBeginTx.afterBeginTxCounter, 1)

	if mmBeginTx.inspectFuncBeginTx != nil {
		mmBeginTx.inspectFuncBeginTx(ctx, txOptions)
	}

	mm_params := DBMockBeginTxParams{ctx, txOptions}

	// Record call args
	mmBeginTx.BeginTxMock.mutex.Lock()
	mmBeginTx.BeginTxMock.callArgs = append(mmBeginTx.BeginTxMock.callArgs, &mm_params)
	mmBeginTx.BeginTxMock.mutex.Unlock()

	for _, e := range mmBeginTx.BeginTxMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmBeginTx.BeginTxMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeginTx.BeginTxMock.defaultExpectation.Counter, 1)
		mm_want := mmBeginTx.BeginTxMock.defaultExpectation.params
		mm_got := DBMockBeginTxParams{ctx, txOptions}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBeginTx.t.Errorf("DBMock.BeginTx got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBeginTx.BeginTxMock.defaultExpectation.results
		if mm_results == nil {
			mmBeginTx.t.Fatal("No results are set for the DBMock.BeginTx")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBeginTx.funcBeginTx != nil {
		return mmBeginTx.funcBeginTx(ctx, txOptions)
	}
	mmBeginTx.t.Fatalf("Unexpected call to DBMock.BeginTx. %v %v", ctx, txOptions)
	return
}

// BeginTxAfterCounter returns a count of finished DBMock.BeginTx invocations
func (mmBeginTx *DBMock) BeginTxAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTx.afterBeginTxCounter)
}

// BeginTxBeforeCounter returns a count of DBMock.BeginTx invocations
func (mmBeginTx *DBMock) BeginTxBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTx.beforeBeginTxCounter)
}

// Calls returns a list of arguments used in each call to DBMock.BeginTx.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBeginTx *mDBMockBeginTx) Calls() []*DBMockBeginTxParams {
	mmBeginTx.mutex.RLock()

	argCopy := make([]*DBMockBeginTxParams, len(mmBeginTx.callArgs))
	copy(argCopy, mmBeginTx.callArgs)

	mmBeginTx.mutex.RUnlock()

	return argCopy
}

// MinimockBeginTxDone returns true if the count of the BeginTx invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockBeginTxDone() bool {
	for _, e := range m.BeginTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginTx != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginTxInspect logs each unmet expectation
func (m *DBMock) MinimockBeginTxInspect() {
	for _, e := range m.BeginTxMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.BeginTx with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginTxMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		if m.BeginTxMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.BeginTx")
		} else {
			m.t.Errorf("Expected call to DBMock.BeginTx with params: %#v", *m.BeginTxMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginTx != nil && mm_atomic.LoadUint64(&m.afterBeginTxCounter) < 1 {
		m.t.Error("Expected call to DBMock.BeginTx")
	}
}

type mDBMockClose struct {
	mock               *DBMock
	defaultExpectation *DBMockCloseExpectation
	expectations       []*DBMockCloseExpectation
}

// DBMockCloseExpectation specifies expectation struct of the DB.Close
type DBMockCloseExpectation struct {
	mock *DBMock

	Counter uint64
}

// Expect sets up expected params for DB.Close
func (mmClose *mDBMockClose) Expect() *mDBMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("DBMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &DBMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the DB.Close
func (mmClose *mDBMockClose) Inspect(f func()) *mDBMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for DBMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by DB.Close
func (mmClose *mDBMockClose) Return() *DBMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("DBMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &DBMockCloseExpectation{mock: mmClose.mock}
	}

	return mmClose.mock
}

// Set uses given function f to mock the DB.Close method
func (mmClose *mDBMockClose) Set(f func()) *DBMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the DB.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the DB.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements db.DB
func (mmClose *DBMock) Close() {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClose.funcClose != nil {
		mmClose.funcClose()
		return
	}
	mmClose.t.Fatalf("Unexpected call to DBMock.Close.")

}

// CloseAfterCounter returns a count of finished DBMock.Close invocations
func (mmClose *DBMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of DBMock.Close invocations
func (mmClose *DBMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *DBMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to DBMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to DBMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to DBMock.Close")
	}
}

type mDBMockExecContext struct {
	mock               *DBMock
	defaultExpectation *DBMockExecContextExpectation
	expectations       []*DBMockExecContextExpectation

	callArgs []*DBMockExecContextParams
	mutex    sync.RWMutex
}

// DBMockExecContextExpectation specifies expectation struct of the DB.ExecContext
type DBMockExecContextExpectation struct {
	mock    *DBMock
	params  *DBMockExecContextParams
	results *DBMockExecContextResults
	Counter uint64
}

// DBMockExecContextParams contains parameters of the DB.ExecContext
type DBMockExecContextParams struct {
	ctx  context.Context
	q    mm_db.Query
	args []interface{}
}

// DBMockExecContextResults contains results of the DB.ExecContext
type DBMockExecContextResults struct {
	c2  pgconn.CommandTag
	err error
}

// Expect sets up expected params for DB.ExecContext
func (mmExecContext *mDBMockExecContext) Expect(ctx context.Context, q mm_db.Query, args ...interface{}) *mDBMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &DBMockExecContextExpectation{}
	}

	mmExecContext.defaultExpectation.params = &DBMockExecContextParams{ctx, q, args}
	for _, e := range mmExecContext.expectations {
		if minimock.Equal(e.params, mmExecContext.defaultExpectation.params) {
			mmExecContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExecContext.defaultExpectation.params)
		}
	}

	return mmExecContext
}

// Inspect accepts an inspector function that has same arguments as the DB.ExecContext
func (mmExecContext *mDBMockExecContext) Inspect(f func(ctx context.Context, q mm_db.Query, args ...interface{})) *mDBMockExecContext {
	if mmExecContext.mock.inspectFuncExecContext != nil {
		mmExecContext.mock.t.Fatalf("Inspect function is already set for DBMock.ExecContext")
	}

	mmExecContext.mock.inspectFuncExecContext = f

	return mmExecContext
}

// Return sets up results that will be returned by DB.ExecContext
func (mmExecContext *mDBMockExecContext) Return(c2 pgconn.CommandTag, err error) *DBMock {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &DBMockExecContextExpectation{mock: mmExecContext.mock}
	}
	mmExecContext.defaultExpectation.results = &DBMockExecContextResults{c2, err}
	return mmExecContext.mock
}

// Set uses given function f to mock the DB.ExecContext method
func (mmExecContext *mDBMockExecContext) Set(f func(ctx context.Context, q mm_db.Query, args ...interface{}) (c2 pgconn.CommandTag, err error)) *DBMock {
	if mmExecContext.defaultExpectation != nil {
		mmExecContext.mock.t.Fatalf("Default expectation is already set for the DB.ExecContext method")
	}

	if len(mmExecContext.expectations) > 0 {
		mmExecContext.mock.t.Fatalf("Some expectations are already set for the DB.ExecContext method")
	}

	mmExecContext.mock.funcExecContext = f
	return mmExecContext.mock
}

// When sets expectation for the DB.ExecContext which will trigger the result defined by the following
// Then helper
func (mmExecContext *mDBMockExecContext) When(ctx context.Context, q mm_db.Query, args ...interface{}) *DBMockExecContextExpectation {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("DBMock.ExecContext mock is already set by Set")
	}

	expectation := &DBMockExecContextExpectation{
		mock:   mmExecContext.mock,
		params: &DBMockExecContextParams{ctx, q, args},
	}
	mmExecContext.expectations = append(mmExecContext.expectations, expectation)
	return expectation
}

// Then sets up DB.ExecContext return parameters for the expectation previously defined by the When method
func (e *DBMockExecContextExpectation) Then(c2 pgconn.CommandTag, err error) *DBMock {
	e.results = &DBMockExecContextResults{c2, err}
	return e.mock
}

// ExecContext implements db.DB
func (mmExecContext *DBMock) ExecContext(ctx context.Context, q mm_db.Query, args ...interface{}) (c2 pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExecContext.beforeExecContextCounter, 1)
	defer mm_atomic.AddUint64(&mmExecContext.afterExecContextCounter, 1)

	if mmExecContext.inspectFuncExecContext != nil {
		mmExecContext.inspectFuncExecContext(ctx, q, args...)
	}

	mm_params := DBMockExecContextParams{ctx, q, args}

	// Record call args
	mmExecContext.ExecContextMock.mutex.Lock()
	mmExecContext.ExecContextMock.callArgs = append(mmExecContext.ExecContextMock.callArgs, &mm_params)
	mmExecContext.ExecContextMock.mutex.Unlock()

	for _, e := range mmExecContext.ExecContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmExecContext.ExecContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExecContext.ExecContextMock.defaultExpectation.Counter, 1)
		mm_want := mmExecContext.ExecContextMock.defaultExpectation.params
		mm_got := DBMockExecContextParams{ctx, q, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExecContext.t.Errorf("DBMock.ExecContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExecContext.ExecContextMock.defaultExpectation.results
		if mm_results == nil {
			mmExecContext.t.Fatal("No results are set for the DBMock.ExecContext")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmExecContext.funcExecContext != nil {
		return mmExecContext.funcExecContext(ctx, q, args...)
	}
	mmExecContext.t.Fatalf("Unexpected call to DBMock.ExecContext. %v %v %v", ctx, q, args)
	return
}

// ExecContextAfterCounter returns a count of finished DBMock.ExecContext invocations
func (mmExecContext *DBMock) ExecContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecContext.afterExecContextCounter)
}

// ExecContextBeforeCounter returns a count of DBMock.ExecContext invocations
func (mmExecContext *DBMock) ExecContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecContext.beforeExecContextCounter)
}

// Calls returns a list of arguments used in each call to DBMock.ExecContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExecContext *mDBMockExecContext) Calls() []*DBMockExecContextParams {
	mmExecContext.mutex.RLock()

	argCopy := make([]*DBMockExecContextParams, len(mmExecContext.callArgs))
	copy(argCopy, mmExecContext.callArgs)

	mmExecContext.mutex.RUnlock()

	return argCopy
}

// MinimockExecContextDone returns true if the count of the ExecContext invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockExecContextDone() bool {
	for _, e := range m.ExecContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecContext != nil && mm_atomic.LoadUint64(&m.afterExecContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockExecContextInspect logs each unmet expectation
func (m *DBMock) MinimockExecContextInspect() {
	for _, e := range m.ExecContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.ExecContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecContextCounter) < 1 {
		if m.ExecContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.ExecContext")
		} else {
			m.t.Errorf("Expected call to DBMock.ExecContext with params: %#v", *m.ExecContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecContext != nil && mm_atomic.LoadUint64(&m.afterExecContextCounter) < 1 {
		m.t.Error("Expected call to DBMock.ExecContext")
	}
}

type mDBMockPing struct {
	mock               *DBMock
	defaultExpectation *DBMockPingExpectation
	expectations       []*DBMockPingExpectation

	callArgs []*DBMockPingParams
	mutex    sync.RWMutex
}

// DBMockPingExpectation specifies expectation struct of the DB.Ping
type DBMockPingExpectation struct {
	mock    *DBMock
	params  *DBMockPingParams
	results *DBMockPingResults
	Counter uint64
}

// DBMockPingParams contains parameters of the DB.Ping
type DBMockPingParams struct {
	ctx context.Context
}

// DBMockPingResults contains results of the DB.Ping
type DBMockPingResults struct {
	err error
}

// Expect sets up expected params for DB.Ping
func (mmPing *mDBMockPing) Expect(ctx context.Context) *mDBMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("DBMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &DBMockPingExpectation{}
	}

	mmPing.defaultExpectation.params = &DBMockPingParams{ctx}
	for _, e := range mmPing.expectations {
		if minimock.Equal(e.params, mmPing.defaultExpectation.params) {
			mmPing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPing.defaultExpectation.params)
		}
	}

	return mmPing
}

// Inspect accepts an inspector function that has same arguments as the DB.Ping
func (mmPing *mDBMockPing) Inspect(f func(ctx context.Context)) *mDBMockPing {
	if mmPing.mock.inspectFuncPing != nil {
		mmPing.mock.t.Fatalf("Inspect function is already set for DBMock.Ping")
	}

	mmPing.mock.inspectFuncPing = f

	return mmPing
}

// Return sets up results that will be returned by DB.Ping
func (mmPing *mDBMockPing) Return(err error) *DBMock {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("DBMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &DBMockPingExpectation{mock: mmPing.mock}
	}
	mmPing.defaultExpectation.results = &DBMockPingResults{err}
	return mmPing.mock
}

// Set uses given function f to mock the DB.Ping method
func (mmPing *mDBMockPing) Set(f func(ctx context.Context) (err error)) *DBMock {
	if mmPing.defaultExpectation != nil {
		mmPing.mock.t.Fatalf("Default expectation is already set for the DB.Ping method")
	}

	if len(mmPing.expectations) > 0 {
		mmPing.mock.t.Fatalf("Some expectations are already set for the DB.Ping method")
	}

	mmPing.mock.funcPing = f
	return mmPing.mock
}

// When sets expectation for the DB.Ping which will trigger the result defined by the following
// Then helper
func (mmPing *mDBMockPing) When(ctx context.Context) *DBMockPingExpectation {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("DBMock.Ping mock is already set by Set")
	}

	expectation := &DBMockPingExpectation{
		mock:   mmPing.mock,
		params: &DBMockPingParams{ctx},
	}
	mmPing.expectations = append(mmPing.expectations, expectation)
	return expectation
}

// Then sets up DB.Ping return parameters for the expectation previously defined by the When method
func (e *DBMockPingExpectation) Then(err error) *DBMock {
	e.results = &DBMockPingResults{err}
	return e.mock
}

// Ping implements db.DB
func (mmPing *DBMock) Ping(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPing.beforePingCounter, 1)
	defer mm_atomic.AddUint64(&mmPing.afterPingCounter, 1)

	if mmPing.inspectFuncPing != nil {
		mmPing.inspectFuncPing(ctx)
	}

	mm_params := DBMockPingParams{ctx}

	// Record call args
	mmPing.PingMock.mutex.Lock()
	mmPing.PingMock.callArgs = append(mmPing.PingMock.callArgs, &mm_params)
	mmPing.PingMock.mutex.Unlock()

	for _, e := range mmPing.PingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPing.PingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPing.PingMock.defaultExpectation.Counter, 1)
		mm_want := mmPing.PingMock.defaultExpectation.params
		mm_got := DBMockPingParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPing.t.Errorf("DBMock.Ping got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPing.PingMock.defaultExpectation.results
		if mm_results == nil {
			mmPing.t.Fatal("No results are set for the DBMock.Ping")
		}
		return (*mm_results).err
	}
	if mmPing.funcPing != nil {
		return mmPing.funcPing(ctx)
	}
	mmPing.t.Fatalf("Unexpected call to DBMock.Ping. %v", ctx)
	return
}

// PingAfterCounter returns a count of finished DBMock.Ping invocations
func (mmPing *DBMock) PingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.afterPingCounter)
}

// PingBeforeCounter returns a count of DBMock.Ping invocations
func (mmPing *DBMock) PingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.beforePingCounter)
}

// Calls returns a list of arguments used in each call to DBMock.Ping.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPing *mDBMockPing) Calls() []*DBMockPingParams {
	mmPing.mutex.RLock()

	argCopy := make([]*DBMockPingParams, len(mmPing.callArgs))
	copy(argCopy, mmPing.callArgs)

	mmPing.mutex.RUnlock()

	return argCopy
}

// MinimockPingDone returns true if the count of the Ping invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockPingDone() bool {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		return false
	}
	return true
}

// MinimockPingInspect logs each unmet expectation
func (m *DBMock) MinimockPingInspect() {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.Ping with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		if m.PingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.Ping")
		} else {
			m.t.Errorf("Expected call to DBMock.Ping with params: %#v", *m.PingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && mm_atomic.LoadUint64(&m.afterPingCounter) < 1 {
		m.t.Error("Expected call to DBMock.Ping")
	}
}

type mDBMockQueryContext struct {
	mock               *DBMock
	defaultExpectation *DBMockQueryContextExpectation
	expectations       []*DBMockQueryContextExpectation

	callArgs []*DBMockQueryContextParams
	mutex    sync.RWMutex
}

// DBMockQueryContextExpectation specifies expectation struct of the DB.QueryContext
type DBMockQueryContextExpectation struct {
	mock    *DBMock
	params  *DBMockQueryContextParams
	results *DBMockQueryContextResults
	Counter uint64
}

// DBMockQueryContextParams contains parameters of the DB.QueryContext
type DBMockQueryContextParams struct {
	ctx  context.Context
	q    mm_db.Query
	args []interface{}
}

// DBMockQueryContextResults contains results of the DB.QueryContext
type DBMockQueryContextResults struct {
	r1  pgx.Rows
	err error
}

// Expect sets up expected params for DB.QueryContext
func (mmQueryContext *mDBMockQueryContext) Expect(ctx context.Context, q mm_db.Query, args ...interface{}) *mDBMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &DBMockQueryContextExpectation{}
	}

	mmQueryContext.defaultExpectation.params = &DBMockQueryContextParams{ctx, q, args}
	for _, e := range mmQueryContext.expectations {
		if minimock.Equal(e.params, mmQueryContext.defaultExpectation.params) {
			mmQueryContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryContext.defaultExpectation.params)
		}
	}

	return mmQueryContext
}

// Inspect accepts an inspector function that has same arguments as the DB.QueryContext
func (mmQueryContext *mDBMockQueryContext) Inspect(f func(ctx context.Context, q mm_db.Query, args ...interface{})) *mDBMockQueryContext {
	if mmQueryContext.mock.inspectFuncQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("Inspect function is already set for DBMock.QueryContext")
	}

	mmQueryContext.mock.inspectFuncQueryContext = f

	return mmQueryContext
}

// Return sets up results that will be returned by DB.QueryContext
func (mmQueryContext *mDBMockQueryContext) Return(r1 pgx.Rows, err error) *DBMock {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &DBMockQueryContextExpectation{mock: mmQueryContext.mock}
	}
	mmQueryContext.defaultExpectation.results = &DBMockQueryContextResults{r1, err}
	return mmQueryContext.mock
}

// Set uses given function f to mock the DB.QueryContext method
func (mmQueryContext *mDBMockQueryContext) Set(f func(ctx context.Context, q mm_db.Query, args ...interface{}) (r1 pgx.Rows, err error)) *DBMock {
	if mmQueryContext.defaultExpectation != nil {
		mmQueryContext.mock.t.Fatalf("Default expectation is already set for the DB.QueryContext method")
	}

	if len(mmQueryContext.expectations) > 0 {
		mmQueryContext.mock.t.Fatalf("Some expectations are already set for the DB.QueryContext method")
	}

	mmQueryContext.mock.funcQueryContext = f
	return mmQueryContext.mock
}

// When sets expectation for the DB.QueryContext which will trigger the result defined by the following
// Then helper
func (mmQueryContext *mDBMockQueryContext) When(ctx context.Context, q mm_db.Query, args ...interface{}) *DBMockQueryContextExpectation {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("DBMock.QueryContext mock is already set by Set")
	}

	expectation := &DBMockQueryContextExpectation{
		mock:   mmQueryContext.mock,
		params: &DBMockQueryContextParams{ctx, q, args},
	}
	mmQueryContext.expectations = append(mmQueryContext.expectations, expectation)
	return expectation
}

// Then sets up DB.QueryContext return parameters for the expectation previously defined by the When method
func (e *DBMockQueryContextExpectation) Then(r1 pgx.Rows, err error) *DBMock {
	e.results = &DBMockQueryContextResults{r1, err}
	return e.mock
}

// QueryContext implements db.DB
func (mmQueryContext *DBMock) QueryContext(ctx context.Context, q mm_db.Query, args ...interface{}) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQueryContext.beforeQueryContextCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryContext.afterQueryContextCounter, 1)

	if mmQueryContext.inspectFuncQueryContext != nil {
		mmQueryContext.inspectFuncQueryContext(ctx, q, args...)
	}

	mm_params := DBMockQueryContextParams{ctx, q, args}

	// Record call args
	mmQueryContext.QueryContextMock.mutex.Lock()
	mmQueryContext.QueryContextMock.callArgs = append(mmQueryContext.QueryContextMock.callArgs, &mm_params)
	mmQueryContext.QueryContextMock.mutex.Unlock()

	for _, e := range mmQueryContext.QueryContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQueryContext.QueryContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryContext.QueryContextMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryContext.QueryContextMock.defaultExpectation.params
		mm_got := DBMockQueryContextParams{ctx, q, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryContext.t.Errorf("DBMock.QueryContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryContext.QueryContextMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryContext.t.Fatal("No results are set for the DBMock.QueryContext")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQueryContext.funcQueryContext != nil {
		return mmQueryContext.funcQueryContext(ctx, q, args...)
	}
	mmQueryContext.t.Fatalf("Unexpected call to DBMock.QueryContext. %v %v %v", ctx, q, args)
	return
}

// QueryContextAfterCounter returns a count of finished DBMock.QueryContext invocations
func (mmQueryContext *DBMock) QueryContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryContext.afterQueryContextCounter)
}

// QueryContextBeforeCounter returns a count of DBMock.QueryContext invocations
func (mmQueryContext *DBMock) QueryContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryContext.beforeQueryContextCounter)
}

// Calls returns a list of arguments used in each call to DBMock.QueryContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryContext *mDBMockQueryContext) Calls() []*DBMockQueryContextParams {
	mmQueryContext.mutex.RLock()

	argCopy := make([]*DBMockQueryContextParams, len(mmQueryContext.callArgs))
	copy(argCopy, mmQueryContext.callArgs)

	mmQueryContext.mutex.RUnlock()

	return argCopy
}

// MinimockQueryContextDone returns true if the count of the QueryContext invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockQueryContextDone() bool {
	for _, e := range m.QueryContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryContext != nil && mm_atomic.LoadUint64(&m.afterQueryContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryContextInspect logs each unmet expectation
func (m *DBMock) MinimockQueryContextInspect() {
	for _, e := range m.QueryContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.QueryContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryContextCounter) < 1 {
		if m.QueryContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.QueryContext")
		} else {
			m.t.Errorf("Expected call to DBMock.QueryContext with params: %#v", *m.QueryContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryContext != nil && mm_atomic.LoadUint64(&m.afterQueryContextCounter) < 1 {
		m.t.Error("Expected call to DBMock.QueryContext")
	}
}

type mDBMockQueryRowContext struct {
	mock               *DBMock
	defaultExpectation *DBMockQueryRowContextExpectation
	expectations       []*DBMockQueryRowContextExpectation

	callArgs []*DBMockQueryRowContextParams
	mutex    sync.RWMutex
}

// DBMockQueryRowContextExpectation specifies expectation struct of the DB.QueryRowContext
type DBMockQueryRowContextExpectation struct {
	mock    *DBMock
	params  *DBMockQueryRowContextParams
	results *DBMockQueryRowContextResults
	Counter uint64
}

// DBMockQueryRowContextParams contains parameters of the DB.QueryRowContext
type DBMockQueryRowContextParams struct {
	ctx  context.Context
	q    mm_db.Query
	args []interface{}
}

// DBMockQueryRowContextResults contains results of the DB.QueryRowContext
type DBMockQueryRowContextResults struct {
	r1 pgx.Row
}

// Expect sets up expected params for DB.QueryRowContext
func (mmQueryRowContext *mDBMockQueryRowContext) Expect(ctx context.Context, q mm_db.Query, args ...interface{}) *mDBMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &DBMockQueryRowContextExpectation{}
	}

	mmQueryRowContext.defaultExpectation.params = &DBMockQueryRowContextParams{ctx, q, args}
	for _, e := range mmQueryRowContext.expectations {
		if minimock.Equal(e.params, mmQueryRowContext.defaultExpectation.params) {
			mmQueryRowContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRowContext.defaultExpectation.params)
		}
	}

	return mmQueryRowContext
}

// Inspect accepts an inspector function that has same arguments as the DB.QueryRowContext
func (mmQueryRowContext *mDBMockQueryRowContext) Inspect(f func(ctx context.Context, q mm_db.Query, args ...interface{})) *mDBMockQueryRowContext {
	if mmQueryRowContext.mock.inspectFuncQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("Inspect function is already set for DBMock.QueryRowContext")
	}

	mmQueryRowContext.mock.inspectFuncQueryRowContext = f

	return mmQueryRowContext
}

// Return sets up results that will be returned by DB.QueryRowContext
func (mmQueryRowContext *mDBMockQueryRowContext) Return(r1 pgx.Row) *DBMock {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &DBMockQueryRowContextExpectation{mock: mmQueryRowContext.mock}
	}
	mmQueryRowContext.defaultExpectation.results = &DBMockQueryRowContextResults{r1}
	return mmQueryRowContext.mock
}

// Set uses given function f to mock the DB.QueryRowContext method
func (mmQueryRowContext *mDBMockQueryRowContext) Set(f func(ctx context.Context, q mm_db.Query, args ...interface{}) (r1 pgx.Row)) *DBMock {
	if mmQueryRowContext.defaultExpectation != nil {
		mmQueryRowContext.mock.t.Fatalf("Default expectation is already set for the DB.QueryRowContext method")
	}

	if len(mmQueryRowContext.expectations) > 0 {
		mmQueryRowContext.mock.t.Fatalf("Some expectations are already set for the DB.QueryRowContext method")
	}

	mmQueryRowContext.mock.funcQueryRowContext = f
	return mmQueryRowContext.mock
}

// When sets expectation for the DB.QueryRowContext which will trigger the result defined by the following
// Then helper
func (mmQueryRowContext *mDBMockQueryRowContext) When(ctx context.Context, q mm_db.Query, args ...interface{}) *DBMockQueryRowContextExpectation {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("DBMock.QueryRowContext mock is already set by Set")
	}

	expectation := &DBMockQueryRowContextExpectation{
		mock:   mmQueryRowContext.mock,
		params: &DBMockQueryRowContextParams{ctx, q, args},
	}
	mmQueryRowContext.expectations = append(mmQueryRowContext.expectations, expectation)
	return expectation
}

// Then sets up DB.QueryRowContext return parameters for the expectation previously defined by the When method
func (e *DBMockQueryRowContextExpectation) Then(r1 pgx.Row) *DBMock {
	e.results = &DBMockQueryRowContextResults{r1}
	return e.mock
}

// QueryRowContext implements db.DB
func (mmQueryRowContext *DBMock) QueryRowContext(ctx context.Context, q mm_db.Query, args ...interface{}) (r1 pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRowContext.beforeQueryRowContextCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRowContext.afterQueryRowContextCounter, 1)

	if mmQueryRowContext.inspectFuncQueryRowContext != nil {
		mmQueryRowContext.inspectFuncQueryRowContext(ctx, q, args...)
	}

	mm_params := DBMockQueryRowContextParams{ctx, q, args}

	// Record call args
	mmQueryRowContext.QueryRowContextMock.mutex.Lock()
	mmQueryRowContext.QueryRowContextMock.callArgs = append(mmQueryRowContext.QueryRowContextMock.callArgs, &mm_params)
	mmQueryRowContext.QueryRowContextMock.mutex.Unlock()

	for _, e := range mmQueryRowContext.QueryRowContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRowContext.QueryRowContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRowContext.QueryRowContextMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRowContext.QueryRowContextMock.defaultExpectation.params
		mm_got := DBMockQueryRowContextParams{ctx, q, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRowContext.t.Errorf("DBMock.QueryRowContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRowContext.QueryRowContextMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRowContext.t.Fatal("No results are set for the DBMock.QueryRowContext")
		}
		return (*mm_results).r1
	}
	if mmQueryRowContext.funcQueryRowContext != nil {
		return mmQueryRowContext.funcQueryRowContext(ctx, q, args...)
	}
	mmQueryRowContext.t.Fatalf("Unexpected call to DBMock.QueryRowContext. %v %v %v", ctx, q, args)
	return
}

// QueryRowContextAfterCounter returns a count of finished DBMock.QueryRowContext invocations
func (mmQueryRowContext *DBMock) QueryRowContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRowContext.afterQueryRowContextCounter)
}

// QueryRowContextBeforeCounter returns a count of DBMock.QueryRowContext invocations
func (mmQueryRowContext *DBMock) QueryRowContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRowContext.beforeQueryRowContextCounter)
}

// Calls returns a list of arguments used in each call to DBMock.QueryRowContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRowContext *mDBMockQueryRowContext) Calls() []*DBMockQueryRowContextParams {
	mmQueryRowContext.mutex.RLock()

	argCopy := make([]*DBMockQueryRowContextParams, len(mmQueryRowContext.callArgs))
	copy(argCopy, mmQueryRowContext.callArgs)

	mmQueryRowContext.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowContextDone returns true if the count of the QueryRowContext invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockQueryRowContextDone() bool {
	for _, e := range m.QueryRowContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRowContext != nil && mm_atomic.LoadUint64(&m.afterQueryRowContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryRowContextInspect logs each unmet expectation
func (m *DBMock) MinimockQueryRowContextInspect() {
	for _, e := range m.QueryRowContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.QueryRowContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowContextCounter) < 1 {
		if m.QueryRowContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.QueryRowContext")
		} else {
			m.t.Errorf("Expected call to DBMock.QueryRowContext with params: %#v", *m.QueryRowContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRowContext != nil && mm_atomic.LoadUint64(&m.afterQueryRowContextCounter) < 1 {
		m.t.Error("Expected call to DBMock.QueryRowContext")
	}
}

type mDBMockScanAllContext struct {
	mock               *DBMock
	defaultExpectation *DBMockScanAllContextExpectation
	expectations       []*DBMockScanAllContextExpectation

	callArgs []*DBMockScanAllContextParams
	mutex    sync.RWMutex
}

// DBMockScanAllContextExpectation specifies expectation struct of the DB.ScanAllContext
type DBMockScanAllContextExpectation struct {
	mock    *DBMock
	params  *DBMockScanAllContextParams
	results *DBMockScanAllContextResults
	Counter uint64
}

// DBMockScanAllContextParams contains parameters of the DB.ScanAllContext
type DBMockScanAllContextParams struct {
	ctx  context.Context
	dest interface{}
	q    mm_db.Query
	args []interface{}
}

// DBMockScanAllContextResults contains results of the DB.ScanAllContext
type DBMockScanAllContextResults struct {
	err error
}

// Expect sets up expected params for DB.ScanAllContext
func (mmScanAllContext *mDBMockScanAllContext) Expect(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) *mDBMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &DBMockScanAllContextExpectation{}
	}

	mmScanAllContext.defaultExpectation.params = &DBMockScanAllContextParams{ctx, dest, q, args}
	for _, e := range mmScanAllContext.expectations {
		if minimock.Equal(e.params, mmScanAllContext.defaultExpectation.params) {
			mmScanAllContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanAllContext.defaultExpectation.params)
		}
	}

	return mmScanAllContext
}

// Inspect accepts an inspector function that has same arguments as the DB.ScanAllContext
func (mmScanAllContext *mDBMockScanAllContext) Inspect(f func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{})) *mDBMockScanAllContext {
	if mmScanAllContext.mock.inspectFuncScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("Inspect function is already set for DBMock.ScanAllContext")
	}

	mmScanAllContext.mock.inspectFuncScanAllContext = f

	return mmScanAllContext
}

// Return sets up results that will be returned by DB.ScanAllContext
func (mmScanAllContext *mDBMockScanAllContext) Return(err error) *DBMock {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &DBMockScanAllContextExpectation{mock: mmScanAllContext.mock}
	}
	mmScanAllContext.defaultExpectation.results = &DBMockScanAllContextResults{err}
	return mmScanAllContext.mock
}

// Set uses given function f to mock the DB.ScanAllContext method
func (mmScanAllContext *mDBMockScanAllContext) Set(f func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error)) *DBMock {
	if mmScanAllContext.defaultExpectation != nil {
		mmScanAllContext.mock.t.Fatalf("Default expectation is already set for the DB.ScanAllContext method")
	}

	if len(mmScanAllContext.expectations) > 0 {
		mmScanAllContext.mock.t.Fatalf("Some expectations are already set for the DB.ScanAllContext method")
	}

	mmScanAllContext.mock.funcScanAllContext = f
	return mmScanAllContext.mock
}

// When sets expectation for the DB.ScanAllContext which will trigger the result defined by the following
// Then helper
func (mmScanAllContext *mDBMockScanAllContext) When(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) *DBMockScanAllContextExpectation {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("DBMock.ScanAllContext mock is already set by Set")
	}

	expectation := &DBMockScanAllContextExpectation{
		mock:   mmScanAllContext.mock,
		params: &DBMockScanAllContextParams{ctx, dest, q, args},
	}
	mmScanAllContext.expectations = append(mmScanAllContext.expectations, expectation)
	return expectation
}

// Then sets up DB.ScanAllContext return parameters for the expectation previously defined by the When method
func (e *DBMockScanAllContextExpectation) Then(err error) *DBMock {
	e.results = &DBMockScanAllContextResults{err}
	return e.mock
}

// ScanAllContext implements db.DB
func (mmScanAllContext *DBMock) ScanAllContext(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScanAllContext.beforeScanAllContextCounter, 1)
	defer mm_atomic.AddUint64(&mmScanAllContext.afterScanAllContextCounter, 1)

	if mmScanAllContext.inspectFuncScanAllContext != nil {
		mmScanAllContext.inspectFuncScanAllContext(ctx, dest, q, args...)
	}

	mm_params := DBMockScanAllContextParams{ctx, dest, q, args}

	// Record call args
	mmScanAllContext.ScanAllContextMock.mutex.Lock()
	mmScanAllContext.ScanAllContextMock.callArgs = append(mmScanAllContext.ScanAllContextMock.callArgs, &mm_params)
	mmScanAllContext.ScanAllContextMock.mutex.Unlock()

	for _, e := range mmScanAllContext.ScanAllContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScanAllContext.ScanAllContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanAllContext.ScanAllContextMock.defaultExpectation.Counter, 1)
		mm_want := mmScanAllContext.ScanAllContextMock.defaultExpectation.params
		mm_got := DBMockScanAllContextParams{ctx, dest, q, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanAllContext.t.Errorf("DBMock.ScanAllContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanAllContext.ScanAllContextMock.defaultExpectation.results
		if mm_results == nil {
			mmScanAllContext.t.Fatal("No results are set for the DBMock.ScanAllContext")
		}
		return (*mm_results).err
	}
	if mmScanAllContext.funcScanAllContext != nil {
		return mmScanAllContext.funcScanAllContext(ctx, dest, q, args...)
	}
	mmScanAllContext.t.Fatalf("Unexpected call to DBMock.ScanAllContext. %v %v %v %v", ctx, dest, q, args)
	return
}

// ScanAllContextAfterCounter returns a count of finished DBMock.ScanAllContext invocations
func (mmScanAllContext *DBMock) ScanAllContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanAllContext.afterScanAllContextCounter)
}

// ScanAllContextBeforeCounter returns a count of DBMock.ScanAllContext invocations
func (mmScanAllContext *DBMock) ScanAllContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanAllContext.beforeScanAllContextCounter)
}

// Calls returns a list of arguments used in each call to DBMock.ScanAllContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanAllContext *mDBMockScanAllContext) Calls() []*DBMockScanAllContextParams {
	mmScanAllContext.mutex.RLock()

	argCopy := make([]*DBMockScanAllContextParams, len(mmScanAllContext.callArgs))
	copy(argCopy, mmScanAllContext.callArgs)

	mmScanAllContext.mutex.RUnlock()

	return argCopy
}

// MinimockScanAllContextDone returns true if the count of the ScanAllContext invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockScanAllContextDone() bool {
	for _, e := range m.ScanAllContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanAllContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanAllContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanAllContext != nil && mm_atomic.LoadUint64(&m.afterScanAllContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockScanAllContextInspect logs each unmet expectation
func (m *DBMock) MinimockScanAllContextInspect() {
	for _, e := range m.ScanAllContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.ScanAllContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanAllContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanAllContextCounter) < 1 {
		if m.ScanAllContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.ScanAllContext")
		} else {
			m.t.Errorf("Expected call to DBMock.ScanAllContext with params: %#v", *m.ScanAllContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanAllContext != nil && mm_atomic.LoadUint64(&m.afterScanAllContextCounter) < 1 {
		m.t.Error("Expected call to DBMock.ScanAllContext")
	}
}

type mDBMockScanOneContext struct {
	mock               *DBMock
	defaultExpectation *DBMockScanOneContextExpectation
	expectations       []*DBMockScanOneContextExpectation

	callArgs []*DBMockScanOneContextParams
	mutex    sync.RWMutex
}

// DBMockScanOneContextExpectation specifies expectation struct of the DB.ScanOneContext
type DBMockScanOneContextExpectation struct {
	mock    *DBMock
	params  *DBMockScanOneContextParams
	results *DBMockScanOneContextResults
	Counter uint64
}

// DBMockScanOneContextParams contains parameters of the DB.ScanOneContext
type DBMockScanOneContextParams struct {
	ctx  context.Context
	dest interface{}
	q    mm_db.Query
	args []interface{}
}

// DBMockScanOneContextResults contains results of the DB.ScanOneContext
type DBMockScanOneContextResults struct {
	err error
}

// Expect sets up expected params for DB.ScanOneContext
func (mmScanOneContext *mDBMockScanOneContext) Expect(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) *mDBMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &DBMockScanOneContextExpectation{}
	}

	mmScanOneContext.defaultExpectation.params = &DBMockScanOneContextParams{ctx, dest, q, args}
	for _, e := range mmScanOneContext.expectations {
		if minimock.Equal(e.params, mmScanOneContext.defaultExpectation.params) {
			mmScanOneContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanOneContext.defaultExpectation.params)
		}
	}

	return mmScanOneContext
}

// Inspect accepts an inspector function that has same arguments as the DB.ScanOneContext
func (mmScanOneContext *mDBMockScanOneContext) Inspect(f func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{})) *mDBMockScanOneContext {
	if mmScanOneContext.mock.inspectFuncScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("Inspect function is already set for DBMock.ScanOneContext")
	}

	mmScanOneContext.mock.inspectFuncScanOneContext = f

	return mmScanOneContext
}

// Return sets up results that will be returned by DB.ScanOneContext
func (mmScanOneContext *mDBMockScanOneContext) Return(err error) *DBMock {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &DBMockScanOneContextExpectation{mock: mmScanOneContext.mock}
	}
	mmScanOneContext.defaultExpectation.results = &DBMockScanOneContextResults{err}
	return mmScanOneContext.mock
}

// Set uses given function f to mock the DB.ScanOneContext method
func (mmScanOneContext *mDBMockScanOneContext) Set(f func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error)) *DBMock {
	if mmScanOneContext.defaultExpectation != nil {
		mmScanOneContext.mock.t.Fatalf("Default expectation is already set for the DB.ScanOneContext method")
	}

	if len(mmScanOneContext.expectations) > 0 {
		mmScanOneContext.mock.t.Fatalf("Some expectations are already set for the DB.ScanOneContext method")
	}

	mmScanOneContext.mock.funcScanOneContext = f
	return mmScanOneContext.mock
}

// When sets expectation for the DB.ScanOneContext which will trigger the result defined by the following
// Then helper
func (mmScanOneContext *mDBMockScanOneContext) When(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) *DBMockScanOneContextExpectation {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("DBMock.ScanOneContext mock is already set by Set")
	}

	expectation := &DBMockScanOneContextExpectation{
		mock:   mmScanOneContext.mock,
		params: &DBMockScanOneContextParams{ctx, dest, q, args},
	}
	mmScanOneContext.expectations = append(mmScanOneContext.expectations, expectation)
	return expectation
}

// Then sets up DB.ScanOneContext return parameters for the expectation previously defined by the When method
func (e *DBMockScanOneContextExpectation) Then(err error) *DBMock {
	e.results = &DBMockScanOneContextResults{err}
	return e.mock
}

// ScanOneContext implements db.DB
func (mmScanOneContext *DBMock) ScanOneContext(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScanOneContext.beforeScanOneContextCounter, 1)
	defer mm_atomic.AddUint64(&mmScanOneContext.afterScanOneContextCounter, 1)

	if mmScanOneContext.inspectFuncScanOneContext != nil {
		mmScanOneContext.inspectFuncScanOneContext(ctx, dest, q, args...)
	}

	mm_params := DBMockScanOneContextParams{ctx, dest, q, args}

	// Record call args
	mmScanOneContext.ScanOneContextMock.mutex.Lock()
	mmScanOneContext.ScanOneContextMock.callArgs = append(mmScanOneContext.ScanOneContextMock.callArgs, &mm_params)
	mmScanOneContext.ScanOneContextMock.mutex.Unlock()

	for _, e := range mmScanOneContext.ScanOneContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScanOneContext.ScanOneContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanOneContext.ScanOneContextMock.defaultExpectation.Counter, 1)
		mm_want := mmScanOneContext.ScanOneContextMock.defaultExpectation.params
		mm_got := DBMockScanOneContextParams{ctx, dest, q, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanOneContext.t.Errorf("DBMock.ScanOneContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanOneContext.ScanOneContextMock.defaultExpectation.results
		if mm_results == nil {
			mmScanOneContext.t.Fatal("No results are set for the DBMock.ScanOneContext")
		}
		return (*mm_results).err
	}
	if mmScanOneContext.funcScanOneContext != nil {
		return mmScanOneContext.funcScanOneContext(ctx, dest, q, args...)
	}
	mmScanOneContext.t.Fatalf("Unexpected call to DBMock.ScanOneContext. %v %v %v %v", ctx, dest, q, args)
	return
}

// ScanOneContextAfterCounter returns a count of finished DBMock.ScanOneContext invocations
func (mmScanOneContext *DBMock) ScanOneContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanOneContext.afterScanOneContextCounter)
}

// ScanOneContextBeforeCounter returns a count of DBMock.ScanOneContext invocations
func (mmScanOneContext *DBMock) ScanOneContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanOneContext.beforeScanOneContextCounter)
}

// Calls returns a list of arguments used in each call to DBMock.ScanOneContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanOneContext *mDBMockScanOneContext) Calls() []*DBMockScanOneContextParams {
	mmScanOneContext.mutex.RLock()

	argCopy := make([]*DBMockScanOneContextParams, len(mmScanOneContext.callArgs))
	copy(argCopy, mmScanOneContext.callArgs)

	mmScanOneContext.mutex.RUnlock()

	return argCopy
}

// MinimockScanOneContextDone returns true if the count of the ScanOneContext invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockScanOneContextDone() bool {
	for _, e := range m.ScanOneContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanOneContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanOneContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanOneContext != nil && mm_atomic.LoadUint64(&m.afterScanOneContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockScanOneContextInspect logs each unmet expectation
func (m *DBMock) MinimockScanOneContextInspect() {
	for _, e := range m.ScanOneContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.ScanOneContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanOneContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanOneContextCounter) < 1 {
		if m.ScanOneContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.ScanOneContext")
		} else {
			m.t.Errorf("Expected call to DBMock.ScanOneContext with params: %#v", *m.ScanOneContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanOneContext != nil && mm_atomic.LoadUint64(&m.afterScanOneContextCounter) < 1 {
		m.t.Error("Expected call to DBMock.ScanOneContext")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DBMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBeginTxInspect()

			m.MinimockCloseInspect()

			m.MinimockExecContextInspect()

			m.MinimockPingInspect()

			m.MinimockQueryContextInspect()

			m.MinimockQueryRowContextInspect()

			m.MinimockScanAllContextInspect()

			m.MinimockScanOneContextInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginTxDone() &&
		m.MinimockCloseDone() &&
		m.MinimockExecContextDone() &&
		m.MinimockPingDone() &&
		m.MinimockQueryContextDone() &&
		m.MinimockQueryRowContextDone() &&
		m.MinimockScanAllContextDone() &&
		m.MinimockScanOneContextDone()
}
