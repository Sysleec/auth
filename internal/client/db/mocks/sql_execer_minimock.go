package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/Sysleec/auth/internal/client/db.SQLExecer -o sql_execer_minimock.go -n SQLExecerMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_db "github.com/Sysleec/auth/internal/client/db"
	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
)

// SQLExecerMock implements db.SQLExecer
type SQLExecerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcExecContext          func(ctx context.Context, q mm_db.Query, args ...interface{}) (c2 pgconn.CommandTag, err error)
	inspectFuncExecContext   func(ctx context.Context, q mm_db.Query, args ...interface{})
	afterExecContextCounter  uint64
	beforeExecContextCounter uint64
	ExecContextMock          mSQLExecerMockExecContext

	funcQueryContext          func(ctx context.Context, q mm_db.Query, args ...interface{}) (r1 pgx.Rows, err error)
	inspectFuncQueryContext   func(ctx context.Context, q mm_db.Query, args ...interface{})
	afterQueryContextCounter  uint64
	beforeQueryContextCounter uint64
	QueryContextMock          mSQLExecerMockQueryContext

	funcQueryRowContext          func(ctx context.Context, q mm_db.Query, args ...interface{}) (r1 pgx.Row)
	inspectFuncQueryRowContext   func(ctx context.Context, q mm_db.Query, args ...interface{})
	afterQueryRowContextCounter  uint64
	beforeQueryRowContextCounter uint64
	QueryRowContextMock          mSQLExecerMockQueryRowContext

	funcScanAllContext          func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error)
	inspectFuncScanAllContext   func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{})
	afterScanAllContextCounter  uint64
	beforeScanAllContextCounter uint64
	ScanAllContextMock          mSQLExecerMockScanAllContext

	funcScanOneContext          func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error)
	inspectFuncScanOneContext   func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{})
	afterScanOneContextCounter  uint64
	beforeScanOneContextCounter uint64
	ScanOneContextMock          mSQLExecerMockScanOneContext
}

// NewSQLExecerMock returns a mock for db.SQLExecer
func NewSQLExecerMock(t minimock.Tester) *SQLExecerMock {
	m := &SQLExecerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExecContextMock = mSQLExecerMockExecContext{mock: m}
	m.ExecContextMock.callArgs = []*SQLExecerMockExecContextParams{}

	m.QueryContextMock = mSQLExecerMockQueryContext{mock: m}
	m.QueryContextMock.callArgs = []*SQLExecerMockQueryContextParams{}

	m.QueryRowContextMock = mSQLExecerMockQueryRowContext{mock: m}
	m.QueryRowContextMock.callArgs = []*SQLExecerMockQueryRowContextParams{}

	m.ScanAllContextMock = mSQLExecerMockScanAllContext{mock: m}
	m.ScanAllContextMock.callArgs = []*SQLExecerMockScanAllContextParams{}

	m.ScanOneContextMock = mSQLExecerMockScanOneContext{mock: m}
	m.ScanOneContextMock.callArgs = []*SQLExecerMockScanOneContextParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSQLExecerMockExecContext struct {
	mock               *SQLExecerMock
	defaultExpectation *SQLExecerMockExecContextExpectation
	expectations       []*SQLExecerMockExecContextExpectation

	callArgs []*SQLExecerMockExecContextParams
	mutex    sync.RWMutex
}

// SQLExecerMockExecContextExpectation specifies expectation struct of the SQLExecer.ExecContext
type SQLExecerMockExecContextExpectation struct {
	mock    *SQLExecerMock
	params  *SQLExecerMockExecContextParams
	results *SQLExecerMockExecContextResults
	Counter uint64
}

// SQLExecerMockExecContextParams contains parameters of the SQLExecer.ExecContext
type SQLExecerMockExecContextParams struct {
	ctx  context.Context
	q    mm_db.Query
	args []interface{}
}

// SQLExecerMockExecContextResults contains results of the SQLExecer.ExecContext
type SQLExecerMockExecContextResults struct {
	c2  pgconn.CommandTag
	err error
}

// Expect sets up expected params for SQLExecer.ExecContext
func (mmExecContext *mSQLExecerMockExecContext) Expect(ctx context.Context, q mm_db.Query, args ...interface{}) *mSQLExecerMockExecContext {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("SQLExecerMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &SQLExecerMockExecContextExpectation{}
	}

	mmExecContext.defaultExpectation.params = &SQLExecerMockExecContextParams{ctx, q, args}
	for _, e := range mmExecContext.expectations {
		if minimock.Equal(e.params, mmExecContext.defaultExpectation.params) {
			mmExecContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExecContext.defaultExpectation.params)
		}
	}

	return mmExecContext
}

// Inspect accepts an inspector function that has same arguments as the SQLExecer.ExecContext
func (mmExecContext *mSQLExecerMockExecContext) Inspect(f func(ctx context.Context, q mm_db.Query, args ...interface{})) *mSQLExecerMockExecContext {
	if mmExecContext.mock.inspectFuncExecContext != nil {
		mmExecContext.mock.t.Fatalf("Inspect function is already set for SQLExecerMock.ExecContext")
	}

	mmExecContext.mock.inspectFuncExecContext = f

	return mmExecContext
}

// Return sets up results that will be returned by SQLExecer.ExecContext
func (mmExecContext *mSQLExecerMockExecContext) Return(c2 pgconn.CommandTag, err error) *SQLExecerMock {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("SQLExecerMock.ExecContext mock is already set by Set")
	}

	if mmExecContext.defaultExpectation == nil {
		mmExecContext.defaultExpectation = &SQLExecerMockExecContextExpectation{mock: mmExecContext.mock}
	}
	mmExecContext.defaultExpectation.results = &SQLExecerMockExecContextResults{c2, err}
	return mmExecContext.mock
}

// Set uses given function f to mock the SQLExecer.ExecContext method
func (mmExecContext *mSQLExecerMockExecContext) Set(f func(ctx context.Context, q mm_db.Query, args ...interface{}) (c2 pgconn.CommandTag, err error)) *SQLExecerMock {
	if mmExecContext.defaultExpectation != nil {
		mmExecContext.mock.t.Fatalf("Default expectation is already set for the SQLExecer.ExecContext method")
	}

	if len(mmExecContext.expectations) > 0 {
		mmExecContext.mock.t.Fatalf("Some expectations are already set for the SQLExecer.ExecContext method")
	}

	mmExecContext.mock.funcExecContext = f
	return mmExecContext.mock
}

// When sets expectation for the SQLExecer.ExecContext which will trigger the result defined by the following
// Then helper
func (mmExecContext *mSQLExecerMockExecContext) When(ctx context.Context, q mm_db.Query, args ...interface{}) *SQLExecerMockExecContextExpectation {
	if mmExecContext.mock.funcExecContext != nil {
		mmExecContext.mock.t.Fatalf("SQLExecerMock.ExecContext mock is already set by Set")
	}

	expectation := &SQLExecerMockExecContextExpectation{
		mock:   mmExecContext.mock,
		params: &SQLExecerMockExecContextParams{ctx, q, args},
	}
	mmExecContext.expectations = append(mmExecContext.expectations, expectation)
	return expectation
}

// Then sets up SQLExecer.ExecContext return parameters for the expectation previously defined by the When method
func (e *SQLExecerMockExecContextExpectation) Then(c2 pgconn.CommandTag, err error) *SQLExecerMock {
	e.results = &SQLExecerMockExecContextResults{c2, err}
	return e.mock
}

// ExecContext implements db.SQLExecer
func (mmExecContext *SQLExecerMock) ExecContext(ctx context.Context, q mm_db.Query, args ...interface{}) (c2 pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExecContext.beforeExecContextCounter, 1)
	defer mm_atomic.AddUint64(&mmExecContext.afterExecContextCounter, 1)

	if mmExecContext.inspectFuncExecContext != nil {
		mmExecContext.inspectFuncExecContext(ctx, q, args...)
	}

	mm_params := SQLExecerMockExecContextParams{ctx, q, args}

	// Record call args
	mmExecContext.ExecContextMock.mutex.Lock()
	mmExecContext.ExecContextMock.callArgs = append(mmExecContext.ExecContextMock.callArgs, &mm_params)
	mmExecContext.ExecContextMock.mutex.Unlock()

	for _, e := range mmExecContext.ExecContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmExecContext.ExecContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExecContext.ExecContextMock.defaultExpectation.Counter, 1)
		mm_want := mmExecContext.ExecContextMock.defaultExpectation.params
		mm_got := SQLExecerMockExecContextParams{ctx, q, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExecContext.t.Errorf("SQLExecerMock.ExecContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExecContext.ExecContextMock.defaultExpectation.results
		if mm_results == nil {
			mmExecContext.t.Fatal("No results are set for the SQLExecerMock.ExecContext")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmExecContext.funcExecContext != nil {
		return mmExecContext.funcExecContext(ctx, q, args...)
	}
	mmExecContext.t.Fatalf("Unexpected call to SQLExecerMock.ExecContext. %v %v %v", ctx, q, args)
	return
}

// ExecContextAfterCounter returns a count of finished SQLExecerMock.ExecContext invocations
func (mmExecContext *SQLExecerMock) ExecContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecContext.afterExecContextCounter)
}

// ExecContextBeforeCounter returns a count of SQLExecerMock.ExecContext invocations
func (mmExecContext *SQLExecerMock) ExecContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExecContext.beforeExecContextCounter)
}

// Calls returns a list of arguments used in each call to SQLExecerMock.ExecContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExecContext *mSQLExecerMockExecContext) Calls() []*SQLExecerMockExecContextParams {
	mmExecContext.mutex.RLock()

	argCopy := make([]*SQLExecerMockExecContextParams, len(mmExecContext.callArgs))
	copy(argCopy, mmExecContext.callArgs)

	mmExecContext.mutex.RUnlock()

	return argCopy
}

// MinimockExecContextDone returns true if the count of the ExecContext invocations corresponds
// the number of defined expectations
func (m *SQLExecerMock) MinimockExecContextDone() bool {
	for _, e := range m.ExecContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecContext != nil && mm_atomic.LoadUint64(&m.afterExecContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockExecContextInspect logs each unmet expectation
func (m *SQLExecerMock) MinimockExecContextInspect() {
	for _, e := range m.ExecContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SQLExecerMock.ExecContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecContextCounter) < 1 {
		if m.ExecContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SQLExecerMock.ExecContext")
		} else {
			m.t.Errorf("Expected call to SQLExecerMock.ExecContext with params: %#v", *m.ExecContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExecContext != nil && mm_atomic.LoadUint64(&m.afterExecContextCounter) < 1 {
		m.t.Error("Expected call to SQLExecerMock.ExecContext")
	}
}

type mSQLExecerMockQueryContext struct {
	mock               *SQLExecerMock
	defaultExpectation *SQLExecerMockQueryContextExpectation
	expectations       []*SQLExecerMockQueryContextExpectation

	callArgs []*SQLExecerMockQueryContextParams
	mutex    sync.RWMutex
}

// SQLExecerMockQueryContextExpectation specifies expectation struct of the SQLExecer.QueryContext
type SQLExecerMockQueryContextExpectation struct {
	mock    *SQLExecerMock
	params  *SQLExecerMockQueryContextParams
	results *SQLExecerMockQueryContextResults
	Counter uint64
}

// SQLExecerMockQueryContextParams contains parameters of the SQLExecer.QueryContext
type SQLExecerMockQueryContextParams struct {
	ctx  context.Context
	q    mm_db.Query
	args []interface{}
}

// SQLExecerMockQueryContextResults contains results of the SQLExecer.QueryContext
type SQLExecerMockQueryContextResults struct {
	r1  pgx.Rows
	err error
}

// Expect sets up expected params for SQLExecer.QueryContext
func (mmQueryContext *mSQLExecerMockQueryContext) Expect(ctx context.Context, q mm_db.Query, args ...interface{}) *mSQLExecerMockQueryContext {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("SQLExecerMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &SQLExecerMockQueryContextExpectation{}
	}

	mmQueryContext.defaultExpectation.params = &SQLExecerMockQueryContextParams{ctx, q, args}
	for _, e := range mmQueryContext.expectations {
		if minimock.Equal(e.params, mmQueryContext.defaultExpectation.params) {
			mmQueryContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryContext.defaultExpectation.params)
		}
	}

	return mmQueryContext
}

// Inspect accepts an inspector function that has same arguments as the SQLExecer.QueryContext
func (mmQueryContext *mSQLExecerMockQueryContext) Inspect(f func(ctx context.Context, q mm_db.Query, args ...interface{})) *mSQLExecerMockQueryContext {
	if mmQueryContext.mock.inspectFuncQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("Inspect function is already set for SQLExecerMock.QueryContext")
	}

	mmQueryContext.mock.inspectFuncQueryContext = f

	return mmQueryContext
}

// Return sets up results that will be returned by SQLExecer.QueryContext
func (mmQueryContext *mSQLExecerMockQueryContext) Return(r1 pgx.Rows, err error) *SQLExecerMock {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("SQLExecerMock.QueryContext mock is already set by Set")
	}

	if mmQueryContext.defaultExpectation == nil {
		mmQueryContext.defaultExpectation = &SQLExecerMockQueryContextExpectation{mock: mmQueryContext.mock}
	}
	mmQueryContext.defaultExpectation.results = &SQLExecerMockQueryContextResults{r1, err}
	return mmQueryContext.mock
}

// Set uses given function f to mock the SQLExecer.QueryContext method
func (mmQueryContext *mSQLExecerMockQueryContext) Set(f func(ctx context.Context, q mm_db.Query, args ...interface{}) (r1 pgx.Rows, err error)) *SQLExecerMock {
	if mmQueryContext.defaultExpectation != nil {
		mmQueryContext.mock.t.Fatalf("Default expectation is already set for the SQLExecer.QueryContext method")
	}

	if len(mmQueryContext.expectations) > 0 {
		mmQueryContext.mock.t.Fatalf("Some expectations are already set for the SQLExecer.QueryContext method")
	}

	mmQueryContext.mock.funcQueryContext = f
	return mmQueryContext.mock
}

// When sets expectation for the SQLExecer.QueryContext which will trigger the result defined by the following
// Then helper
func (mmQueryContext *mSQLExecerMockQueryContext) When(ctx context.Context, q mm_db.Query, args ...interface{}) *SQLExecerMockQueryContextExpectation {
	if mmQueryContext.mock.funcQueryContext != nil {
		mmQueryContext.mock.t.Fatalf("SQLExecerMock.QueryContext mock is already set by Set")
	}

	expectation := &SQLExecerMockQueryContextExpectation{
		mock:   mmQueryContext.mock,
		params: &SQLExecerMockQueryContextParams{ctx, q, args},
	}
	mmQueryContext.expectations = append(mmQueryContext.expectations, expectation)
	return expectation
}

// Then sets up SQLExecer.QueryContext return parameters for the expectation previously defined by the When method
func (e *SQLExecerMockQueryContextExpectation) Then(r1 pgx.Rows, err error) *SQLExecerMock {
	e.results = &SQLExecerMockQueryContextResults{r1, err}
	return e.mock
}

// QueryContext implements db.SQLExecer
func (mmQueryContext *SQLExecerMock) QueryContext(ctx context.Context, q mm_db.Query, args ...interface{}) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQueryContext.beforeQueryContextCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryContext.afterQueryContextCounter, 1)

	if mmQueryContext.inspectFuncQueryContext != nil {
		mmQueryContext.inspectFuncQueryContext(ctx, q, args...)
	}

	mm_params := SQLExecerMockQueryContextParams{ctx, q, args}

	// Record call args
	mmQueryContext.QueryContextMock.mutex.Lock()
	mmQueryContext.QueryContextMock.callArgs = append(mmQueryContext.QueryContextMock.callArgs, &mm_params)
	mmQueryContext.QueryContextMock.mutex.Unlock()

	for _, e := range mmQueryContext.QueryContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQueryContext.QueryContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryContext.QueryContextMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryContext.QueryContextMock.defaultExpectation.params
		mm_got := SQLExecerMockQueryContextParams{ctx, q, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryContext.t.Errorf("SQLExecerMock.QueryContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryContext.QueryContextMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryContext.t.Fatal("No results are set for the SQLExecerMock.QueryContext")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQueryContext.funcQueryContext != nil {
		return mmQueryContext.funcQueryContext(ctx, q, args...)
	}
	mmQueryContext.t.Fatalf("Unexpected call to SQLExecerMock.QueryContext. %v %v %v", ctx, q, args)
	return
}

// QueryContextAfterCounter returns a count of finished SQLExecerMock.QueryContext invocations
func (mmQueryContext *SQLExecerMock) QueryContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryContext.afterQueryContextCounter)
}

// QueryContextBeforeCounter returns a count of SQLExecerMock.QueryContext invocations
func (mmQueryContext *SQLExecerMock) QueryContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryContext.beforeQueryContextCounter)
}

// Calls returns a list of arguments used in each call to SQLExecerMock.QueryContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryContext *mSQLExecerMockQueryContext) Calls() []*SQLExecerMockQueryContextParams {
	mmQueryContext.mutex.RLock()

	argCopy := make([]*SQLExecerMockQueryContextParams, len(mmQueryContext.callArgs))
	copy(argCopy, mmQueryContext.callArgs)

	mmQueryContext.mutex.RUnlock()

	return argCopy
}

// MinimockQueryContextDone returns true if the count of the QueryContext invocations corresponds
// the number of defined expectations
func (m *SQLExecerMock) MinimockQueryContextDone() bool {
	for _, e := range m.QueryContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryContext != nil && mm_atomic.LoadUint64(&m.afterQueryContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryContextInspect logs each unmet expectation
func (m *SQLExecerMock) MinimockQueryContextInspect() {
	for _, e := range m.QueryContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SQLExecerMock.QueryContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryContextCounter) < 1 {
		if m.QueryContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SQLExecerMock.QueryContext")
		} else {
			m.t.Errorf("Expected call to SQLExecerMock.QueryContext with params: %#v", *m.QueryContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryContext != nil && mm_atomic.LoadUint64(&m.afterQueryContextCounter) < 1 {
		m.t.Error("Expected call to SQLExecerMock.QueryContext")
	}
}

type mSQLExecerMockQueryRowContext struct {
	mock               *SQLExecerMock
	defaultExpectation *SQLExecerMockQueryRowContextExpectation
	expectations       []*SQLExecerMockQueryRowContextExpectation

	callArgs []*SQLExecerMockQueryRowContextParams
	mutex    sync.RWMutex
}

// SQLExecerMockQueryRowContextExpectation specifies expectation struct of the SQLExecer.QueryRowContext
type SQLExecerMockQueryRowContextExpectation struct {
	mock    *SQLExecerMock
	params  *SQLExecerMockQueryRowContextParams
	results *SQLExecerMockQueryRowContextResults
	Counter uint64
}

// SQLExecerMockQueryRowContextParams contains parameters of the SQLExecer.QueryRowContext
type SQLExecerMockQueryRowContextParams struct {
	ctx  context.Context
	q    mm_db.Query
	args []interface{}
}

// SQLExecerMockQueryRowContextResults contains results of the SQLExecer.QueryRowContext
type SQLExecerMockQueryRowContextResults struct {
	r1 pgx.Row
}

// Expect sets up expected params for SQLExecer.QueryRowContext
func (mmQueryRowContext *mSQLExecerMockQueryRowContext) Expect(ctx context.Context, q mm_db.Query, args ...interface{}) *mSQLExecerMockQueryRowContext {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("SQLExecerMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &SQLExecerMockQueryRowContextExpectation{}
	}

	mmQueryRowContext.defaultExpectation.params = &SQLExecerMockQueryRowContextParams{ctx, q, args}
	for _, e := range mmQueryRowContext.expectations {
		if minimock.Equal(e.params, mmQueryRowContext.defaultExpectation.params) {
			mmQueryRowContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRowContext.defaultExpectation.params)
		}
	}

	return mmQueryRowContext
}

// Inspect accepts an inspector function that has same arguments as the SQLExecer.QueryRowContext
func (mmQueryRowContext *mSQLExecerMockQueryRowContext) Inspect(f func(ctx context.Context, q mm_db.Query, args ...interface{})) *mSQLExecerMockQueryRowContext {
	if mmQueryRowContext.mock.inspectFuncQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("Inspect function is already set for SQLExecerMock.QueryRowContext")
	}

	mmQueryRowContext.mock.inspectFuncQueryRowContext = f

	return mmQueryRowContext
}

// Return sets up results that will be returned by SQLExecer.QueryRowContext
func (mmQueryRowContext *mSQLExecerMockQueryRowContext) Return(r1 pgx.Row) *SQLExecerMock {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("SQLExecerMock.QueryRowContext mock is already set by Set")
	}

	if mmQueryRowContext.defaultExpectation == nil {
		mmQueryRowContext.defaultExpectation = &SQLExecerMockQueryRowContextExpectation{mock: mmQueryRowContext.mock}
	}
	mmQueryRowContext.defaultExpectation.results = &SQLExecerMockQueryRowContextResults{r1}
	return mmQueryRowContext.mock
}

// Set uses given function f to mock the SQLExecer.QueryRowContext method
func (mmQueryRowContext *mSQLExecerMockQueryRowContext) Set(f func(ctx context.Context, q mm_db.Query, args ...interface{}) (r1 pgx.Row)) *SQLExecerMock {
	if mmQueryRowContext.defaultExpectation != nil {
		mmQueryRowContext.mock.t.Fatalf("Default expectation is already set for the SQLExecer.QueryRowContext method")
	}

	if len(mmQueryRowContext.expectations) > 0 {
		mmQueryRowContext.mock.t.Fatalf("Some expectations are already set for the SQLExecer.QueryRowContext method")
	}

	mmQueryRowContext.mock.funcQueryRowContext = f
	return mmQueryRowContext.mock
}

// When sets expectation for the SQLExecer.QueryRowContext which will trigger the result defined by the following
// Then helper
func (mmQueryRowContext *mSQLExecerMockQueryRowContext) When(ctx context.Context, q mm_db.Query, args ...interface{}) *SQLExecerMockQueryRowContextExpectation {
	if mmQueryRowContext.mock.funcQueryRowContext != nil {
		mmQueryRowContext.mock.t.Fatalf("SQLExecerMock.QueryRowContext mock is already set by Set")
	}

	expectation := &SQLExecerMockQueryRowContextExpectation{
		mock:   mmQueryRowContext.mock,
		params: &SQLExecerMockQueryRowContextParams{ctx, q, args},
	}
	mmQueryRowContext.expectations = append(mmQueryRowContext.expectations, expectation)
	return expectation
}

// Then sets up SQLExecer.QueryRowContext return parameters for the expectation previously defined by the When method
func (e *SQLExecerMockQueryRowContextExpectation) Then(r1 pgx.Row) *SQLExecerMock {
	e.results = &SQLExecerMockQueryRowContextResults{r1}
	return e.mock
}

// QueryRowContext implements db.SQLExecer
func (mmQueryRowContext *SQLExecerMock) QueryRowContext(ctx context.Context, q mm_db.Query, args ...interface{}) (r1 pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRowContext.beforeQueryRowContextCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRowContext.afterQueryRowContextCounter, 1)

	if mmQueryRowContext.inspectFuncQueryRowContext != nil {
		mmQueryRowContext.inspectFuncQueryRowContext(ctx, q, args...)
	}

	mm_params := SQLExecerMockQueryRowContextParams{ctx, q, args}

	// Record call args
	mmQueryRowContext.QueryRowContextMock.mutex.Lock()
	mmQueryRowContext.QueryRowContextMock.callArgs = append(mmQueryRowContext.QueryRowContextMock.callArgs, &mm_params)
	mmQueryRowContext.QueryRowContextMock.mutex.Unlock()

	for _, e := range mmQueryRowContext.QueryRowContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRowContext.QueryRowContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRowContext.QueryRowContextMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRowContext.QueryRowContextMock.defaultExpectation.params
		mm_got := SQLExecerMockQueryRowContextParams{ctx, q, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRowContext.t.Errorf("SQLExecerMock.QueryRowContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRowContext.QueryRowContextMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRowContext.t.Fatal("No results are set for the SQLExecerMock.QueryRowContext")
		}
		return (*mm_results).r1
	}
	if mmQueryRowContext.funcQueryRowContext != nil {
		return mmQueryRowContext.funcQueryRowContext(ctx, q, args...)
	}
	mmQueryRowContext.t.Fatalf("Unexpected call to SQLExecerMock.QueryRowContext. %v %v %v", ctx, q, args)
	return
}

// QueryRowContextAfterCounter returns a count of finished SQLExecerMock.QueryRowContext invocations
func (mmQueryRowContext *SQLExecerMock) QueryRowContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRowContext.afterQueryRowContextCounter)
}

// QueryRowContextBeforeCounter returns a count of SQLExecerMock.QueryRowContext invocations
func (mmQueryRowContext *SQLExecerMock) QueryRowContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRowContext.beforeQueryRowContextCounter)
}

// Calls returns a list of arguments used in each call to SQLExecerMock.QueryRowContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRowContext *mSQLExecerMockQueryRowContext) Calls() []*SQLExecerMockQueryRowContextParams {
	mmQueryRowContext.mutex.RLock()

	argCopy := make([]*SQLExecerMockQueryRowContextParams, len(mmQueryRowContext.callArgs))
	copy(argCopy, mmQueryRowContext.callArgs)

	mmQueryRowContext.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowContextDone returns true if the count of the QueryRowContext invocations corresponds
// the number of defined expectations
func (m *SQLExecerMock) MinimockQueryRowContextDone() bool {
	for _, e := range m.QueryRowContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRowContext != nil && mm_atomic.LoadUint64(&m.afterQueryRowContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryRowContextInspect logs each unmet expectation
func (m *SQLExecerMock) MinimockQueryRowContextInspect() {
	for _, e := range m.QueryRowContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SQLExecerMock.QueryRowContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowContextCounter) < 1 {
		if m.QueryRowContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SQLExecerMock.QueryRowContext")
		} else {
			m.t.Errorf("Expected call to SQLExecerMock.QueryRowContext with params: %#v", *m.QueryRowContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRowContext != nil && mm_atomic.LoadUint64(&m.afterQueryRowContextCounter) < 1 {
		m.t.Error("Expected call to SQLExecerMock.QueryRowContext")
	}
}

type mSQLExecerMockScanAllContext struct {
	mock               *SQLExecerMock
	defaultExpectation *SQLExecerMockScanAllContextExpectation
	expectations       []*SQLExecerMockScanAllContextExpectation

	callArgs []*SQLExecerMockScanAllContextParams
	mutex    sync.RWMutex
}

// SQLExecerMockScanAllContextExpectation specifies expectation struct of the SQLExecer.ScanAllContext
type SQLExecerMockScanAllContextExpectation struct {
	mock    *SQLExecerMock
	params  *SQLExecerMockScanAllContextParams
	results *SQLExecerMockScanAllContextResults
	Counter uint64
}

// SQLExecerMockScanAllContextParams contains parameters of the SQLExecer.ScanAllContext
type SQLExecerMockScanAllContextParams struct {
	ctx  context.Context
	dest interface{}
	q    mm_db.Query
	args []interface{}
}

// SQLExecerMockScanAllContextResults contains results of the SQLExecer.ScanAllContext
type SQLExecerMockScanAllContextResults struct {
	err error
}

// Expect sets up expected params for SQLExecer.ScanAllContext
func (mmScanAllContext *mSQLExecerMockScanAllContext) Expect(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) *mSQLExecerMockScanAllContext {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("SQLExecerMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &SQLExecerMockScanAllContextExpectation{}
	}

	mmScanAllContext.defaultExpectation.params = &SQLExecerMockScanAllContextParams{ctx, dest, q, args}
	for _, e := range mmScanAllContext.expectations {
		if minimock.Equal(e.params, mmScanAllContext.defaultExpectation.params) {
			mmScanAllContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanAllContext.defaultExpectation.params)
		}
	}

	return mmScanAllContext
}

// Inspect accepts an inspector function that has same arguments as the SQLExecer.ScanAllContext
func (mmScanAllContext *mSQLExecerMockScanAllContext) Inspect(f func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{})) *mSQLExecerMockScanAllContext {
	if mmScanAllContext.mock.inspectFuncScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("Inspect function is already set for SQLExecerMock.ScanAllContext")
	}

	mmScanAllContext.mock.inspectFuncScanAllContext = f

	return mmScanAllContext
}

// Return sets up results that will be returned by SQLExecer.ScanAllContext
func (mmScanAllContext *mSQLExecerMockScanAllContext) Return(err error) *SQLExecerMock {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("SQLExecerMock.ScanAllContext mock is already set by Set")
	}

	if mmScanAllContext.defaultExpectation == nil {
		mmScanAllContext.defaultExpectation = &SQLExecerMockScanAllContextExpectation{mock: mmScanAllContext.mock}
	}
	mmScanAllContext.defaultExpectation.results = &SQLExecerMockScanAllContextResults{err}
	return mmScanAllContext.mock
}

// Set uses given function f to mock the SQLExecer.ScanAllContext method
func (mmScanAllContext *mSQLExecerMockScanAllContext) Set(f func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error)) *SQLExecerMock {
	if mmScanAllContext.defaultExpectation != nil {
		mmScanAllContext.mock.t.Fatalf("Default expectation is already set for the SQLExecer.ScanAllContext method")
	}

	if len(mmScanAllContext.expectations) > 0 {
		mmScanAllContext.mock.t.Fatalf("Some expectations are already set for the SQLExecer.ScanAllContext method")
	}

	mmScanAllContext.mock.funcScanAllContext = f
	return mmScanAllContext.mock
}

// When sets expectation for the SQLExecer.ScanAllContext which will trigger the result defined by the following
// Then helper
func (mmScanAllContext *mSQLExecerMockScanAllContext) When(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) *SQLExecerMockScanAllContextExpectation {
	if mmScanAllContext.mock.funcScanAllContext != nil {
		mmScanAllContext.mock.t.Fatalf("SQLExecerMock.ScanAllContext mock is already set by Set")
	}

	expectation := &SQLExecerMockScanAllContextExpectation{
		mock:   mmScanAllContext.mock,
		params: &SQLExecerMockScanAllContextParams{ctx, dest, q, args},
	}
	mmScanAllContext.expectations = append(mmScanAllContext.expectations, expectation)
	return expectation
}

// Then sets up SQLExecer.ScanAllContext return parameters for the expectation previously defined by the When method
func (e *SQLExecerMockScanAllContextExpectation) Then(err error) *SQLExecerMock {
	e.results = &SQLExecerMockScanAllContextResults{err}
	return e.mock
}

// ScanAllContext implements db.SQLExecer
func (mmScanAllContext *SQLExecerMock) ScanAllContext(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScanAllContext.beforeScanAllContextCounter, 1)
	defer mm_atomic.AddUint64(&mmScanAllContext.afterScanAllContextCounter, 1)

	if mmScanAllContext.inspectFuncScanAllContext != nil {
		mmScanAllContext.inspectFuncScanAllContext(ctx, dest, q, args...)
	}

	mm_params := SQLExecerMockScanAllContextParams{ctx, dest, q, args}

	// Record call args
	mmScanAllContext.ScanAllContextMock.mutex.Lock()
	mmScanAllContext.ScanAllContextMock.callArgs = append(mmScanAllContext.ScanAllContextMock.callArgs, &mm_params)
	mmScanAllContext.ScanAllContextMock.mutex.Unlock()

	for _, e := range mmScanAllContext.ScanAllContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScanAllContext.ScanAllContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanAllContext.ScanAllContextMock.defaultExpectation.Counter, 1)
		mm_want := mmScanAllContext.ScanAllContextMock.defaultExpectation.params
		mm_got := SQLExecerMockScanAllContextParams{ctx, dest, q, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanAllContext.t.Errorf("SQLExecerMock.ScanAllContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanAllContext.ScanAllContextMock.defaultExpectation.results
		if mm_results == nil {
			mmScanAllContext.t.Fatal("No results are set for the SQLExecerMock.ScanAllContext")
		}
		return (*mm_results).err
	}
	if mmScanAllContext.funcScanAllContext != nil {
		return mmScanAllContext.funcScanAllContext(ctx, dest, q, args...)
	}
	mmScanAllContext.t.Fatalf("Unexpected call to SQLExecerMock.ScanAllContext. %v %v %v %v", ctx, dest, q, args)
	return
}

// ScanAllContextAfterCounter returns a count of finished SQLExecerMock.ScanAllContext invocations
func (mmScanAllContext *SQLExecerMock) ScanAllContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanAllContext.afterScanAllContextCounter)
}

// ScanAllContextBeforeCounter returns a count of SQLExecerMock.ScanAllContext invocations
func (mmScanAllContext *SQLExecerMock) ScanAllContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanAllContext.beforeScanAllContextCounter)
}

// Calls returns a list of arguments used in each call to SQLExecerMock.ScanAllContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanAllContext *mSQLExecerMockScanAllContext) Calls() []*SQLExecerMockScanAllContextParams {
	mmScanAllContext.mutex.RLock()

	argCopy := make([]*SQLExecerMockScanAllContextParams, len(mmScanAllContext.callArgs))
	copy(argCopy, mmScanAllContext.callArgs)

	mmScanAllContext.mutex.RUnlock()

	return argCopy
}

// MinimockScanAllContextDone returns true if the count of the ScanAllContext invocations corresponds
// the number of defined expectations
func (m *SQLExecerMock) MinimockScanAllContextDone() bool {
	for _, e := range m.ScanAllContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanAllContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanAllContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanAllContext != nil && mm_atomic.LoadUint64(&m.afterScanAllContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockScanAllContextInspect logs each unmet expectation
func (m *SQLExecerMock) MinimockScanAllContextInspect() {
	for _, e := range m.ScanAllContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SQLExecerMock.ScanAllContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanAllContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanAllContextCounter) < 1 {
		if m.ScanAllContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SQLExecerMock.ScanAllContext")
		} else {
			m.t.Errorf("Expected call to SQLExecerMock.ScanAllContext with params: %#v", *m.ScanAllContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanAllContext != nil && mm_atomic.LoadUint64(&m.afterScanAllContextCounter) < 1 {
		m.t.Error("Expected call to SQLExecerMock.ScanAllContext")
	}
}

type mSQLExecerMockScanOneContext struct {
	mock               *SQLExecerMock
	defaultExpectation *SQLExecerMockScanOneContextExpectation
	expectations       []*SQLExecerMockScanOneContextExpectation

	callArgs []*SQLExecerMockScanOneContextParams
	mutex    sync.RWMutex
}

// SQLExecerMockScanOneContextExpectation specifies expectation struct of the SQLExecer.ScanOneContext
type SQLExecerMockScanOneContextExpectation struct {
	mock    *SQLExecerMock
	params  *SQLExecerMockScanOneContextParams
	results *SQLExecerMockScanOneContextResults
	Counter uint64
}

// SQLExecerMockScanOneContextParams contains parameters of the SQLExecer.ScanOneContext
type SQLExecerMockScanOneContextParams struct {
	ctx  context.Context
	dest interface{}
	q    mm_db.Query
	args []interface{}
}

// SQLExecerMockScanOneContextResults contains results of the SQLExecer.ScanOneContext
type SQLExecerMockScanOneContextResults struct {
	err error
}

// Expect sets up expected params for SQLExecer.ScanOneContext
func (mmScanOneContext *mSQLExecerMockScanOneContext) Expect(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) *mSQLExecerMockScanOneContext {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("SQLExecerMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &SQLExecerMockScanOneContextExpectation{}
	}

	mmScanOneContext.defaultExpectation.params = &SQLExecerMockScanOneContextParams{ctx, dest, q, args}
	for _, e := range mmScanOneContext.expectations {
		if minimock.Equal(e.params, mmScanOneContext.defaultExpectation.params) {
			mmScanOneContext.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmScanOneContext.defaultExpectation.params)
		}
	}

	return mmScanOneContext
}

// Inspect accepts an inspector function that has same arguments as the SQLExecer.ScanOneContext
func (mmScanOneContext *mSQLExecerMockScanOneContext) Inspect(f func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{})) *mSQLExecerMockScanOneContext {
	if mmScanOneContext.mock.inspectFuncScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("Inspect function is already set for SQLExecerMock.ScanOneContext")
	}

	mmScanOneContext.mock.inspectFuncScanOneContext = f

	return mmScanOneContext
}

// Return sets up results that will be returned by SQLExecer.ScanOneContext
func (mmScanOneContext *mSQLExecerMockScanOneContext) Return(err error) *SQLExecerMock {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("SQLExecerMock.ScanOneContext mock is already set by Set")
	}

	if mmScanOneContext.defaultExpectation == nil {
		mmScanOneContext.defaultExpectation = &SQLExecerMockScanOneContextExpectation{mock: mmScanOneContext.mock}
	}
	mmScanOneContext.defaultExpectation.results = &SQLExecerMockScanOneContextResults{err}
	return mmScanOneContext.mock
}

// Set uses given function f to mock the SQLExecer.ScanOneContext method
func (mmScanOneContext *mSQLExecerMockScanOneContext) Set(f func(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error)) *SQLExecerMock {
	if mmScanOneContext.defaultExpectation != nil {
		mmScanOneContext.mock.t.Fatalf("Default expectation is already set for the SQLExecer.ScanOneContext method")
	}

	if len(mmScanOneContext.expectations) > 0 {
		mmScanOneContext.mock.t.Fatalf("Some expectations are already set for the SQLExecer.ScanOneContext method")
	}

	mmScanOneContext.mock.funcScanOneContext = f
	return mmScanOneContext.mock
}

// When sets expectation for the SQLExecer.ScanOneContext which will trigger the result defined by the following
// Then helper
func (mmScanOneContext *mSQLExecerMockScanOneContext) When(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) *SQLExecerMockScanOneContextExpectation {
	if mmScanOneContext.mock.funcScanOneContext != nil {
		mmScanOneContext.mock.t.Fatalf("SQLExecerMock.ScanOneContext mock is already set by Set")
	}

	expectation := &SQLExecerMockScanOneContextExpectation{
		mock:   mmScanOneContext.mock,
		params: &SQLExecerMockScanOneContextParams{ctx, dest, q, args},
	}
	mmScanOneContext.expectations = append(mmScanOneContext.expectations, expectation)
	return expectation
}

// Then sets up SQLExecer.ScanOneContext return parameters for the expectation previously defined by the When method
func (e *SQLExecerMockScanOneContextExpectation) Then(err error) *SQLExecerMock {
	e.results = &SQLExecerMockScanOneContextResults{err}
	return e.mock
}

// ScanOneContext implements db.SQLExecer
func (mmScanOneContext *SQLExecerMock) ScanOneContext(ctx context.Context, dest interface{}, q mm_db.Query, args ...interface{}) (err error) {
	mm_atomic.AddUint64(&mmScanOneContext.beforeScanOneContextCounter, 1)
	defer mm_atomic.AddUint64(&mmScanOneContext.afterScanOneContextCounter, 1)

	if mmScanOneContext.inspectFuncScanOneContext != nil {
		mmScanOneContext.inspectFuncScanOneContext(ctx, dest, q, args...)
	}

	mm_params := SQLExecerMockScanOneContextParams{ctx, dest, q, args}

	// Record call args
	mmScanOneContext.ScanOneContextMock.mutex.Lock()
	mmScanOneContext.ScanOneContextMock.callArgs = append(mmScanOneContext.ScanOneContextMock.callArgs, &mm_params)
	mmScanOneContext.ScanOneContextMock.mutex.Unlock()

	for _, e := range mmScanOneContext.ScanOneContextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmScanOneContext.ScanOneContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmScanOneContext.ScanOneContextMock.defaultExpectation.Counter, 1)
		mm_want := mmScanOneContext.ScanOneContextMock.defaultExpectation.params
		mm_got := SQLExecerMockScanOneContextParams{ctx, dest, q, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmScanOneContext.t.Errorf("SQLExecerMock.ScanOneContext got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmScanOneContext.ScanOneContextMock.defaultExpectation.results
		if mm_results == nil {
			mmScanOneContext.t.Fatal("No results are set for the SQLExecerMock.ScanOneContext")
		}
		return (*mm_results).err
	}
	if mmScanOneContext.funcScanOneContext != nil {
		return mmScanOneContext.funcScanOneContext(ctx, dest, q, args...)
	}
	mmScanOneContext.t.Fatalf("Unexpected call to SQLExecerMock.ScanOneContext. %v %v %v %v", ctx, dest, q, args)
	return
}

// ScanOneContextAfterCounter returns a count of finished SQLExecerMock.ScanOneContext invocations
func (mmScanOneContext *SQLExecerMock) ScanOneContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanOneContext.afterScanOneContextCounter)
}

// ScanOneContextBeforeCounter returns a count of SQLExecerMock.ScanOneContext invocations
func (mmScanOneContext *SQLExecerMock) ScanOneContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmScanOneContext.beforeScanOneContextCounter)
}

// Calls returns a list of arguments used in each call to SQLExecerMock.ScanOneContext.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmScanOneContext *mSQLExecerMockScanOneContext) Calls() []*SQLExecerMockScanOneContextParams {
	mmScanOneContext.mutex.RLock()

	argCopy := make([]*SQLExecerMockScanOneContextParams, len(mmScanOneContext.callArgs))
	copy(argCopy, mmScanOneContext.callArgs)

	mmScanOneContext.mutex.RUnlock()

	return argCopy
}

// MinimockScanOneContextDone returns true if the count of the ScanOneContext invocations corresponds
// the number of defined expectations
func (m *SQLExecerMock) MinimockScanOneContextDone() bool {
	for _, e := range m.ScanOneContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanOneContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanOneContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanOneContext != nil && mm_atomic.LoadUint64(&m.afterScanOneContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockScanOneContextInspect logs each unmet expectation
func (m *SQLExecerMock) MinimockScanOneContextInspect() {
	for _, e := range m.ScanOneContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SQLExecerMock.ScanOneContext with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ScanOneContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterScanOneContextCounter) < 1 {
		if m.ScanOneContextMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SQLExecerMock.ScanOneContext")
		} else {
			m.t.Errorf("Expected call to SQLExecerMock.ScanOneContext with params: %#v", *m.ScanOneContextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcScanOneContext != nil && mm_atomic.LoadUint64(&m.afterScanOneContextCounter) < 1 {
		m.t.Error("Expected call to SQLExecerMock.ScanOneContext")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SQLExecerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockExecContextInspect()

			m.MinimockQueryContextInspect()

			m.MinimockQueryRowContextInspect()

			m.MinimockScanAllContextInspect()

			m.MinimockScanOneContextInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SQLExecerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SQLExecerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExecContextDone() &&
		m.MinimockQueryContextDone() &&
		m.MinimockQueryRowContextDone() &&
		m.MinimockScanAllContextDone() &&
		m.MinimockScanOneContextDone()
}
